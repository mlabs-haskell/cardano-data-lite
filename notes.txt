# Issues

Groups are not used.
Alias types shouldn't use fromCBOR.
Union types doesn't support decoding yet.
Construct CBORMap subclasses from CBORMultiMap.

Custom Constructors for optional fields.

Normalize nested composite data structures into their own definitions.
Done.

To Support:
	- Uint32Array
	- number: encode as bigint, not float. We never use float.
	- BigNum: provide field(): number and field_bignum(): BigNum
	- BigNum0: field(): BigNum, unlike above
	- fn remove_field() for nullable/optional fields
	- empty_class type (InfoAction)
	- enum2 (VoteKind)
	- newtype
		constraints:
			len
			min/max/eq
	- check if array provides add()

# Special Cases
- AuxiliaryDataSet.indices(): Uint32Array
- HeaderBody.has_vrf_result()
- HeaderBody.vrf_result_or_nothing(): VRFCert | undefined (To support old versions with nonce_vrf/leader_vrf)
- HeaderBody.new(...) (Uses slot: number) / HeaderBody.new_headerbody(...) (Users slot: BigNum)
	Consider encoding this as custom constructors in the yaml instead of the code.
- Ed25519KeyHashes.contains(keyhash)
- Ed25519KeyHashes.get(index) (Set doesn't support get by index I think)
- VotingProcedures:
	{ voter => { gov_action_id => voting_procedure } }
	Map.insert(voter, gov_action_id, voting_procedure)
	Map.get(voter, gov_action_id): voting_procedure
- VotingProcedure uses vote: VoteKind instead of vote: Vote
	=> Will have to special case
- UpdateCommitteAction::Committee inlines the quorum_threshold field
- Credential
	from_variant/to_variant instead of new_variant/as_variant functions.
	Have commented on the PR.
- TransactionOutput
	this.plutus_data: DataOption (DataHash/PlutusData)
	data_hash()/set_data_hash() => set this.plutus_data as data hash
	plutus_data()/set_plutus_data() => set this.plutus_data as plutus data
- TransactionWitnessSet
	Combines plutus_v1/v2/v3 into single PlutusScripts
- PlutusData
	Is the only remaining union type.
	I'd rather custom code this than coming up with the semantics of the union type in codegen.
- Constr
	Encoding logic is custom
- Redeemer
	CSL API is that of set<Redeemer>
	CDDL says { [redeemer_tag, index] => [plutus_data, ex_units] }
- Costmdls
  CostMdls is Map<Language, CostModel>
  CostModel is custom Vec<Int>:
    get(operation): self[operation]
    set(operation, cost): fill zero from self.len to operation; self[operation] = cost
- TransactionMetadatum
	This is the other (only other I guess) union.
	I'd still rather do this custom.
- Multiasset
	The semantic doesn't exactly fit a map.
	Generic is not needed, judging by CSL TS types.
- Value
	Is a union, but that's not what calls for the custom impl; but the API is quirky.
- Mint
	quirky API.
- DataOption
	Encode PlutusData as #6.24(bytes)
	This is used in TransactionOutput, which is already a custom type.
	DataOption is not exposed in CSL. So maybe we can inline the encoding in TransactionOutput's code.
	Edit: Or maybe we can make DataOption a custom which encodes PlutusData into bytes during serialization
	Edit2: Or maybe we can add codegen for encode as bytes and wrap into tagged.
- ScriptRef
	Encode as #6.24(bytes)
	This is also used in TransactionOutput, which is already a custom type.
	We could inline the encoding there.
- Wherever PlutusScript hides the version number, I've made them explicit.
	Need to confirm with Vlad the semantics of this.
	
# Enum
static variant(): Enum
EnumKind: { variant_name: int }

# Hashes and Signatures
AuxiliaryDataHash
BlockHash
Ed25519Signature
RewardAddress
ScriptHash
AnchorDataHash
TransactionHash
VRFKeyHash
PoolMetadataHash
Vkey

# Other custom types
UnitInterval

# TODO
- Change BigNum0 to BigNum
	annotate on the parent type whether any field needs special treatment
- Change tagged_record's value to extend/value depending on whether it's
	inlining a nested structure or have a single field in the variant.

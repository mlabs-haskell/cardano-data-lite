# block =
#   [ header
#   , transaction_bodies         : [* transaction_body]
#   , transaction_witness_sets   : [* transaction_witness_set]
#   , auxiliary_data_set         : {* transaction_index => auxiliary_data }
#   , invalid_transactions       : [* transaction_index ]
#   ]; Valid blocks must also satisfy the following two constraints:
#    ; 1) the length of transaction_bodies and transaction_witness_sets
#    ;    must be the same
#    ; 2) every transaction_index must be strictly smaller than the
#    ;    length of transaction_bodies
Block:
  type: record
  fields:
    - key: header
      value: Header
    - key: transaction_bodies
      value: TransactionBodies
    - key: transaction_witness_sets
      value: TransactionWitnessSets
    - key: auxiliary_data_set
      value: AuxiliaryDataSet
    - key: invalid_transactions
      value: arrayToUint32Array

TransactionBodies:
  type: array
  item: TransactionBody

TransactionWitnessSets:
  type: array
  item: TransactionWitnessSet

AuxiliaryDataSet:
  type: map
  key: number
  value: AuxiliaryData
  flags:
    - indices_uint32array

# transaction =
#   [ transaction_body
#   , transaction_witness_set
#   , bool
#   , auxiliary_data / null
#   ]
Transaction:
  type: record
  fields:
    - key: body
      value: TransactionBody
    - key: witness_set
      value: TransactionWitnessSet
    - key: is_valid
      value: boolean
    - key: auxiliary_data
      value: AuxiliaryData
      nullable: true

# transaction_index = uint .size 2

# header =
#   [ header_body
#   , body_signature : $kes_signature
#   ]
Header:
  type: record
  fields:
    - key: header_body
      value: HeaderBody
    - key: body_signature
      value: KESSignature

# header_body =
#   [ block_number     : uint
#   , slot             : uint
#   , prev_hash        : $hash32 / null
#   , issuer_vkey      : $vkey
#   , vrf_vkey         : $vrf_vkey
#   , vrf_result       : $vrf_cert ; replaces nonce_vrf and leader_vrf
#   , block_body_size  : uint
#   , block_body_hash  : $hash32 ; merkle triple root
#   , operational_cert
#   , protocol_version
#   ]
HeaderBody:
  type: record
  fields:
    - key: block_number
      value: number
    - key: slot
      value: bignum
    - key: prev_hash
      value: BlockHash
      nullable: true
    - key: issuer_vkey
      value: Vkey
    - key: vrf_vkey
      value: VRFVKey
    - key: vrf_result
      value: VRFCert
    - key: block_body_size
      value: number
    - key: block_body_hash
      value: BlockHash
    - key: operational_cert
      value: OperationalCert
    - key: protocol_version
      value: ProtocolVersion

# operational_cert =
#   [ hot_vkey        : $kes_vkey
#   , sequence_number : uint
#   , kes_period      : uint
#   , sigma           : $signature
#   ]
OperationalCert:
  type: record
  fields:
    - key: hot_vkey
      value: KESVKey
    - key: sequence_number
      value: number
    - key: kes_period
      value: number
    - key: sigma
      value: Ed25519Signature

# next_major_protocol_version = 10
# major_protocol_version = 1..next_major_protocol_version

# protocol_version = [(major_protocol_version, uint)]
ProtocolVersion:
  type: record
  fields:
    - key: major
      value: number
    - key: minor
      value: number

# transaction_body =
#   { 0 : set<transaction_input>             ; inputs
#   , 1 : [* transaction_output]
#   , 2 : coin                               ; fee
#   , ? 3 : uint                             ; time to live
#   , ? 4 : certificates
#   , ? 5 : withdrawals
#   , ? 7 : auxiliary_data_hash
#   , ? 8 : uint                             ; validity interval start
#   , ? 9 : mint
#   , ? 11 : script_data_hash
#   , ? 13 : nonempty_set<transaction_input> ; collateral inputs
#   , ? 14 : required_signers
#   , ? 15 : network_id
#   , ? 16 : transaction_output              ; collateral return
#   , ? 17 : coin                            ; total collateral
#   , ? 18 : nonempty_set<transaction_input> ; reference inputs
#   , ? 19 : voting_procedures               ; New; Voting procedures
#   , ? 20 : proposal_procedures             ; New; Proposal procedures
#   , ? 21 : coin                            ; New; current treasury value
#   , ? 22 : positive_coin                   ; New; donation
#   }
TransactionBody:
  type: struct
  fields:
    - id: 0
      key: inputs
      value: TransactionInputs
    - id: 1
      key: outputs
      value: TransactionOutputs
    - id: 2
      key: fee
      value: bignum
    - id: 3
      key: ttl
      value: bignum
      optional: true
      flags:
        - as_number
    - id: 4
      key: certs
      value: Certificates
      optional: true
    - id: 5
      key: withdrawals
      value: Withdrawals
      optional: true
    - id: 7
      key: auxiliary_data_hash
      value: AuxiliaryDataHash
      optional: true
    - id: 8
      key: validity_start_interval
      value: bignum
      optional: true
    - id: 9
      key: mint
      value: Mint
      optional: true
    - id: 11
      key: script_data_hash
      value: ScriptDataHash
      optional: true
    - id: 13
      key: collateral
      value: TransactionInputs
      optional: true
    - id: 14
      key: required_signers
      value: Ed25519KeyHashes
      optional: true
    - id: 15
      key: network_id
      value: NetworkId
      optional: true
    - id: 16
      key: collateral_return
      value: TransactionOutput
      optional: true
    - id: 17
      key: total_collateral
      value: bignum
      optional: true
    - id: 18
      key: reference_inputs
      value: TransactionInputs
      optional: true
    - id: 19
      key: voting_procedures
      value: VotingProcedures
      optional: true
    - id: 20
      key: voting_proposals
      value: VotingProposals
      optional: true
    - id: 21
      key: current_treasury_value
      value: bignum
      optional: true
    - id: 22
      key: donation
      value: bignum
      optional: true

TransactionInputs:
  type: set
  item: TransactionInput

TransactionOutputs:
  type: array
  item: TransactionOutput

Ed25519KeyHashes:
  type: set
  item: Ed25519KeyHash

# voting_procedures = { + voter => { + gov_action_id => voting_procedure } }
# TODO

# voting_procedure =
#   [ vote
#   , anchor / null
#   ]
VotingProcedure:
  type: record
  fields:
    - key: vote
      value: VoteKind
    - key: anchor
      value: Anchor
      nullable: true

# proposal_procedure =
#   [ deposit : coin
#   , reward_account
#   , gov_action
#   , anchor
#   ]
VotingProposal:
  type: record
  fields:
    - key: deposit
      value: bignum
    - key: reward_account
      value: RewardAddress
    - key: governance_action
      value: GovernanceAction
    - key: anchor
      value: Anchor

# proposal_procedures = nonempty_oset<proposal_procedure>
VotingProposals:
  type: set
  item: VotingProposal

# certificates = nonempty_oset<certificate>
certificates:
  type: set
  item: Certificate

# policy_hash = scripthash

# gov_action =
#   [ parameter_change_action
#   // hard_fork_initiation_action
#   // treasury_withdrawals_action
#   // no_confidence
#   // update_committee
#   // new_constitution
#   // info_action
#   ]
# parameter_change_action = (0, gov_action_id / null, protocol_param_update, policy_hash / null)
# hard_fork_initiation_action = (1, gov_action_id / null, protocol_version)
# treasury_withdrawals_action = (2, { reward_account => coin }, policy_hash / null)
# no_confidence = (3, gov_action_id / null)
# update_committee = (4, gov_action_id / null, set<committee_cold_credential>, { committee_cold_credential => epoch }, unit_interval)
# new_constitution = (5, gov_action_id / null, constitution)
# info_action = 6
GovernanceAction:
  type: tagged_record
  variants:
    - name: parameter_change_action
      tag: 0
      value: ParameterChangeAction
    - name: hard_fork_initiation_action
      tag: 1
      value: HardForkInitiationAction
    - name: treasury_withdrawals_action
      tag: 2
      value: TreasuryWithdrawalsAction
    - name: no_confidence_action
      tag: 3
      value: NoConfidenceAction
    - name: new_committee_action
      value: UpdateCommitteeAction
      tag: 4
    - name: new_constitution_action
      value: NewConstitutionAction
      tag: 5
    - name: info_action
      tag: 6
      value: InfoAction

ParameterChangeAction:
  type: record_fragment
  fields:
    - key: gov_action_id
      value: GovernanceActionId
      nullable: true
    - key: protocol_param_updates
      value: ProtocolParamUpdate
    - key: policy_hash
      value: ScriptHash
      nullable: true

HardForkInitiationAction:
  type: record_fragment
  fields:
    - key: gov_action_id
      value: GovernanceActionId
      nullable: true
    - key: protocol_version
      value: ProtocolVersion

TreasuryWithdrawalsAction:
  type: record_fragment
  fields:
    - key: withdrawals
      value: TreasuryWithdrawals
    - key: policy_hash
      value: ScriptHash
      nullable: true

NoConfidenceAction:
  type: record_fragment
  fields:
    - key: gov_action_id
      value: GovernanceActionId
      nullable: true

UpdateCommitteeAction:
  type: record_fragment
  fields:
    - key: gov_action_id
      value: GovernanceActionId
      nullable: true
    - key: members_to_remove
      value: Credentials
    - key: committee
      value: Committee
    - key: quorom_threshold
      value: UnitInterval

NewConstitutionAction:
  type: record_fragment
  fields:
    - key: gov_action_id
      value: GovernanceActionId
      nullable: true
    - key: constitution
      value: Constitution

InfoAction:
  type: record_fragment
  fields: []

Credentials:
  type: set
  item: Credential

# constitution =
#   [ anchor
#   , scripthash / null
#   ]
Constitution:
  type: record
  fields:
    - key: anchor
      value: Anchor
    - key: scripthash
      value: ScriptHash
      nullable: true

# ; Constitutional Committee Hot KeyHash: 0
# ; Constitutional Committee Hot ScriptHash: 1
# ; DRep KeyHash: 2
# ; DRep ScriptHash: 3
# ; StakingPool KeyHash: 4
# voter =
#   [ 0, addr_keyhash
#   // 1, scripthash
#   // 2, addr_keyhash
#   // 3, scripthash
#   // 4, addr_keyhash
#   ]
Voter: # TODO (custom serializer)
  type: record
  fields:
    - key: constitutional_committee_hot_key
      value: Credential
    - key: drep
      value: Credential
    - name: staking_pool
      value: Ed25519KeyHash

# anchor =
#   [ anchor_url       : url
#   , anchor_data_hash : $hash32
#   ]
Anchor:
  type: record
  fields:
    - key: url
      value: URL
    - key: anchor_data_hash
      value: AnchorDataHash

# ; no - 0
# ; yes - 1
# ; abstain - 2
# vote = 0 .. 2
VoteKind:
  type: enum_simple
  values:
    - name: no
      value: 0
    - name: yes
      value: 1
    - name: abstain
      value: 2

# gov_action_id =
#   [ transaction_id   : $hash32
#   , gov_action_index : uint
#   ]
GovernanceActionId:
  type: record
  fields:
    - key: transaction_id
      value: TransactionHash
    - key: index
      value: number

# required_signers = nonempty_set<addr_keyhash>
# Replaced by Ed25519KeyHashes. See TransactionBody

# transaction_input = [ transaction_id : $hash32
#                     , index : uint
#                     ]
TransactionInput:
  type: record
  fields:
    - key: transaction_id
      value: TransactionHash
    - key: index
      value: number

# ; Both of the Alonzo and Babbage style TxOut formats are equally valid
# ; and can be used interchangeably
# transaction_output = pre_babbage_transaction_output / post_alonzo_transaction_output
#
# pre_babbage_transaction_output =
#   [ address
#   , amount : value
#   , ? datum_hash : $hash32
#   ]
#
# post_alonzo_transaction_output =
#   { 0 : address
#   , 1 : value
#   , ? 2 : datum_option ; datum option
#   , ? 3 : script_ref   ; script reference
#   }
TransactionOutput:
  type: struct
  fields:
    - id: 0
      key: address
      value: Address
    - id: 1
      key: amount
      value: Value
    - id: 2
      key: plutus_data
      value: DataOption
      optional: true
    - id: 3
      key: script_ref
      value: ScriptRef
      optional: true

# script_data_hash = $hash32
# ; This is a hash of data which may affect evaluation of a script.
# ; This data consists of:
# ;   - The redeemers from the transaction_witness_set (the value of field 5).
# ;   - The datums from the transaction_witness_set (the value of field 4).
# ;   - The value in the costmdls map corresponding to the script's language
# ;     (in field 18 of protocol_param_update.)
# ; (In the future it may contain additional protocol parameters.)
# ;
# ; Since this data does not exist in contiguous form inside a transaction, it needs
# ; to be independently constructed by each recipient.
# ;
# ; The bytestring which is hashed is the concatenation of three things:
# ;   redeemers || datums || language views
# ; The redeemers are exactly the data present in the transaction witness set.
# ; Similarly for the datums, if present. If no datums are provided, the middle
# ; field is omitted (i.e. it is the empty/null bytestring).
# ;
# ; language views CDDL:
# ; { * language => script_integrity_data }
# ;
# ; This must be encoded canonically, using the same scheme as in
# ; RFC7049 section 3.9:
# ;  - Maps, strings, and bytestrings must use a definite-length encoding
# ;  - Integers must be as small as possible.
# ;  - The expressions for map length, string length, and bytestring length
# ;    must be as short as possible.
# ;  - The keys in the map must be sorted as follows:
# ;     -  If two keys have different lengths, the shorter one sorts earlier.
# ;     -  If two keys have the same length, the one with the lower value
# ;        in (byte-wise) lexical order sorts earlier.
# ;
# ; For PlutusV1 (language id 0), the language view is the following:
# ;   - the value of costmdls map at key 0 (in other words, the script_integrity_data)
# ;     is encoded as an indefinite length list and the result is encoded as a bytestring.
# ;     (our apologies)
# ;     For example, the script_integrity_data corresponding to the all zero costmodel for V1
# ;     would be encoded as (in hex):
# ;     58a89f00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000ff
# ;   - the language ID tag is also encoded twice. first as a uint then as
# ;     a bytestring. (our apologies)
# ;     Concretely, this means that the language version for V1 is encoded as
# ;     4100 in hex.
# ; For PlutusV2 (language id 1), the language view is the following:
# ;   - the value of costmdls map at key 1 is encoded as an definite length list.
# ;     For example, the script_integrity_data corresponding to the all zero costmodel for V2
# ;     would be encoded as (in hex):
# ;     98af0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
# ;   - the language ID tag is encoded as expected.
# ;     Concretely, this means that the language version for V2 is encoded as
# ;     01 in hex.
# ; For PlutusV3 (language id 2), the language view is the following:
# ;   - the value of costmdls map at key 2 is encoded as a definite length list.
# ;
# ; Note that each Plutus language represented inside a transaction must have
# ; a cost model in the costmdls protocol parameter in order to execute,
# ; regardless of what the script integrity data is.
# ;
# ; Finally, note that in the case that a transaction includes datums but does not
# ; include the redeemers field, the script data format becomes (in hex):
# ; [ 80 | datums | A0 ]
# ; corresponding to a CBOR empty list and an empty map.
# ; Note that a transaction might include the redeemers field and  it to the
# ; empty map, in which case the user supplied encoding of the empty map is used.
# ;
# ; address = bytes
# ; reward_account = bytes
#
# ; address format:
# ; [ 8 bit header | payload ];
# ;
# ; shelley payment addresses:
# ; bit 7: 0
# ; bit 6: base/other
# ; bit 5: pointer/enterprise [for base: stake cred is keyhash/scripthash]
# ; bit 4: payment cred is keyhash/scripthash
# ; bits 3-0: network id
# ;
# ; reward addresses:
# ; bits 7-5: 111
# ; bit 4: credential is keyhash/scripthash
# ; bits 3-0: network id
# ;
# ; byron addresses:
# ; bits 7-4: 1000
#
# ; 0000: base address: keyhash28,keyhash28
# ; 0001: base address: scripthash28,keyhash28
# ; 0010: base address: keyhash28,scripthash28
# ; 0011: base address: scripthash28,scripthash28
# ; 0100: pointer address: keyhash28, 3 variable length uint
# ; 0101: pointer address: scripthash28, 3 variable length uint
# ; 0110: enterprise address: keyhash28
# ; 0111: enterprise address: scripthash28
# ; 1000: byron address
# ; 1110: reward account: keyhash28
# ; 1111: reward account: scripthash28
# ; 1001 - 1101: future formats
# script_data_hash:
#   type: hash32

# certificate =
#   [ stake_registration
#   // stake_deregistration
#   // stake_delegation
#   // pool_registration
#   // pool_retirement
#   // reg_cert
#   // unreg_cert
#   // vote_deleg_cert
#   // stake_vote_deleg_cert
#   // stake_reg_deleg_cert
#   // vote_reg_deleg_cert
#   // stake_vote_reg_deleg_cert
#   // auth_committee_hot_cert
#   // resign_committee_cold_cert
#   // reg_drep_cert
#   // unreg_drep_cert
#   // update_drep_cert
#   ]
#
# stake_registration = (0, stake_credential) ; to be deprecated in era after Conway
# stake_deregistration = (1, stake_credential) ; to be deprecated in era after Conway
# stake_delegation = (2, stake_credential, pool_keyhash)
#
# ; POOL
# pool_registration = (3, pool_params)
# pool_retirement = (4, pool_keyhash, epoch)
#
# ; numbers 5 and 6 used to be the Genesis and MIR certificates respectively,
# ; which were deprecated in Conway
#
# ; DELEG
# reg_cert = (7, stake_credential, coin)
# unreg_cert = (8, stake_credential, coin)
# vote_deleg_cert = (9, stake_credential, drep)
# stake_vote_deleg_cert = (10, stake_credential, pool_keyhash, drep)
# stake_reg_deleg_cert = (11, stake_credential, pool_keyhash, coin)
# vote_reg_deleg_cert = (12, stake_credential, drep, coin)
# stake_vote_reg_deleg_cert = (13, stake_credential, pool_keyhash, drep, coin)
#
# ; GOVCERT
# auth_committee_hot_cert = (14, committee_cold_credential, committee_hot_credential)
# resign_committee_cold_cert = (15, committee_cold_credential, anchor / null)
# reg_drep_cert = (16, drep_credential, coin, anchor / null)
# unreg_drep_cert = (17, drep_credential, coin)
# update_drep_cert = (18, drep_credential, anchor / null)
Certificate:
  type: tagged_record
  variants:
    - name: stake_registration
      tag: 0
      value: StakeRegistration
    - name: stake_deregistration
      tag: 1
      value: StakeDeregistration
    - name: stake_delegation
      tag: 2
      value: StakeDelegation
    - name: pool_registration
      tag: 3
      value: PoolRegistration
    - name: pool_retirement
      tag: 4
      value: PoolRetirement
    - name: reg_cert
      tag: 7
      value: RegCert
    - name: unreg_cert
      tag: 8
      value: UnregCert
    - name: vote_delegation
      tag: 9
      value: VoteDelegation
    - name: stake_and_vote_delegation
      tag: 10
      value: StakeAndVoteDelegation
    - name: stake_registration_and_delegation
      tag: 11
      value: StakeRegistrationAndDelegation
    - name: vote_registration_and_delegation
      tag: 12
      value: VoteRegistrationAndDelegation
    - name: stake_vote_registration_and_delegation
      tag: 13
      value: StakeVoteRegistrationAndDelegation
    - name: committee_hot_auth
      tag: 14
      value: CommitteeHotAuth
    - name: committee_cold_resign
      tag: 15
      value: CommitteeColdResign
    - name: drep_registration
      tag: 16
      value: DrepRegistration
    - name: drep_deregistration
      tag: 17
      value: DrepDeregistration
    - name: drep_update
      tag: 18
      value: DrepUpdate

StakeRegistration:
  type: record_fragment
  fields:
    - key: stake_credential
      value: Credential

StakeDeregistration:
  type: record_fragment
  fields:
    - key: stake_credential
      value: Credential

StakeDelegation:
  type: record_fragment
  fields:
    - key: stake_credential
      value: Credential
    - key: pool_keyhash
      value: Ed25519KeyHash

PoolRegistration:
  type: record_fragment
  fields:
    - key: pool_params
      value: PoolParams

PoolRetirement:
  type: record_fragment
  fields:
    - key: pool_keyhash
      value: Ed25519KeyHash
    - key: epoch
      value: number

RegCert:
  type: record_fragment
  fields:
    - key: stake_credential
      value: Credential
    - key: coin
      value: bignum

UnregCert:
  type: record_fragment
  fields:
    - key: stake_credential
      value: Credential
    - key: coin
      value: bignum

VoteDelegation:
  type: record_fragment
  fields:
    - key: stake_credential
      value: Credential
    - key: drep
      value: DRep

StakeAndVoteDelegation:
  type: record_fragment
  fields:
    - key: stake_credential
      value: Credential
    - key: pool_keyhash
      value: Ed25519KeyHash
    - key: drep
      value: DRep

StakeRegistrationAndDelegation:
  type: record_fragment
  fields:
    - key: stake_credential
      value: Credential
    - key: pool_keyhash
      value: Ed25519KeyHash
    - key: coin
      value: bignum

VoteRegistrationAndDelegation:
  type: record_fragment
  fields:
    - key: stake_credential
      value: Credential
    - key: drep
      value: DRep
    - key: coin
      value: bignum

StakeVoteRegistrationAndDelegation:
  type: record_fragment
  fields:
    - key: stake_credential
      value: Credential
    - key: pool_keyhash
      value: Ed25519KeyHash
    - key: drep
      value: DRep
    - key: coin
      value: bignum

CommitteeHotAuth:
  type: record_fragment
  fields:
    - key: committee_cold_key
      value: Credential
    - key: committee_hot_key
      value: Credential

CommitteeColdResign:
  type: record_fragment
  fields:
    - key: committee_cold_key
      value: Credential
    - key: anchor
      value: Anchor
      nullable: true

DrepRegistration:
  type: record_fragment
  fields:
    - key: voting_credential
      value: Credential
    - key: coin
      value: bignum
    - key: anchor
      value: Anchor
      nullable: true

DrepDeregistration:
  type: record_fragment
  fields:
    - key: drep_credential
      value: Credential
    - key: coin
      value: bignum

DrepUpdate:
  type: record_fragment
  fields:
    - key: drep_credential
      value: Credential
    - key: anchor
      value: Anchor
      nullable: true

# delta_coin = int

# credential =
#   [  0, addr_keyhash
#   // 1, scripthash
#   ]
Credential:
  type: tagged_record
  variants:
    - name: keyhash
      tag: 0
      value: Ed25519KeyHash
    - name: scripthash
      tag: 1
      value: ScriptHash

# drep =
#   [ 0, addr_keyhash
#   // 1, scripthash
#   // 2  ; always abstain
#   // 3  ; always no confidence
#   ]
DRep:
  type: tagged_record
  variants:
    - name: key_hash
      tag: 0
      value: Ed25519KeyHash
    - name: script_hash
      tag: 1
      value: ScriptHash
    - name: always_abstain
      tag: 2
    - name: always_no_confidence
      tag: 3

# stake_credential = credential
# drep_credential = credential
# committee_cold_credential = credential
# committee_hot_credential = credential

# pool_params = ( operator:       pool_keyhash
#               , vrf_keyhash:    vrf_keyhash
#               , pledge:         coin
#               , cost:           coin
#               , margin:         unit_interval
#               , reward_account: reward_account
#               , pool_owners:    set<addr_keyhash>
#               , relays:         [* relay]
#               , pool_metadata:  pool_metadata / null
#               )
PoolParams:
  type: record
  fields:
    - key: operator
      value: Ed25519KeyHash
    - key: vrf_keyhash
      value: VRFKeyHash
    - key: pledge
      value: bignum
    - key: cost
      value: bignum
    - key: margin
      value: UnitInterval
    - key: reward_account
      value: RewardAddress
    - key: pool_owners
      value: Ed25519KeyHashes
    - key: relays
      value: Relays
    - key: pool_metadata
      value: PoolMetadata
      nullable: true

Relays:
  type: array
  item: Relay

# port = uint .le 65535
# ipv4 = bytes .size 4
# ipv6 = bytes .size 16
# dns_name = tstr .size (0..128)

Ipv4:
  type: newtype
  item: bytes
  constraints:
    len:
      eq: 4

Ipv6:
  type: newtype
  item: bytes
  constraints:
    len:
      eq: 16

DNSRecordAorAAAA:
  type: newtype
  item: string
  constraints:
    len:
      max: 64

DNSRecordSRV:
  type: newtype
  item: string
  constraints:
    len:
      max: 64

# single_host_addr = ( 0
#                    , port / null
#                    , ipv4 / null
#                    , ipv6 / null
#                    )
# single_host_name = ( 1
#                    , port / null
#                    , dns_name ; An A or AAAA DNS record
#                    )
# multi_host_name = ( 2
#                    , dns_name ; A SRV DNS record
#                    )
# relay =
#   [  single_host_addr
#   // single_host_name
#   // multi_host_name
#   ]
Relay:
  type: tagged_record
  variants:
    - name: single_host_addr
      tag: 0
      value: SingleHostAddr
    - name: single_host_name
      tag: 1
      value: SingleHostName
    - name: multi_host_name
      tag: 2
      value: MultiHostName

SingleHostAddr:
  type: record_fragment
  fields:
    - key: port
      value: number
      nullable: true
    - key: ipv4
      value: Ipv4
      nullable: true
    - key: ipv6
      value: Ipv6
      nullable: true

SingleHostName:
  type: record_fragment
  fields:
    - key: port
      value: number
      nullable: true
    - key: dns_name
      value: DNSRecordAorAAAA

MultiHostName:
  type: record_fragment
  fields:
    - key: dns_name
      value: DNSRecordSRV

# pool_metadata = [url, pool_metadata_hash]
PoolMetadata:
  type: record
  fields:
    - key: url
      value: URL
    - key: pool_metadata_hash
      value: PoolMetadataHash

# url = tstr .size (0..128)
URL:
  type: newtype
  item: string
  constraints:
    len:
      min: 0
      max: 128

# withdrawals = { + reward_account => coin }
Withdrawals:
  type: map
  key: RewardAddress
  value: bignum

# protocol_param_update =
#   { ? 0:  coin                   ; minfee A
#   , ? 1:  coin                   ; minfee B
#   , ? 2:  uint                   ; max block body size
#   , ? 3:  uint                   ; max transaction size
#   , ? 4:  uint                   ; max block header size
#   , ? 5:  coin                   ; key deposit
#   , ? 6:  coin                   ; pool deposit
#   , ? 7:  epoch                  ; maximum epoch
#   , ? 8:  uint                   ; n_opt: desired number of stake pools
#   , ? 9:  nonnegative_interval   ; pool pledge influence
#   , ? 10: unit_interval          ; expansion rate
#   , ? 11: unit_interval          ; treasury growth rate
#   , ? 16: coin                   ; min pool cost
#   , ? 17: coin                   ; ada per utxo byte
#   , ? 18: costmdls               ; cost models for script languages
#   , ? 19: ex_unit_prices         ; execution costs
#   , ? 20: ex_units               ; max tx ex units
#   , ? 21: ex_units               ; max block ex units
#   , ? 22: uint                   ; max value size
#   , ? 23: uint                   ; collateral percentage
#   , ? 24: uint                   ; max collateral inputs
#   , ? 25: pool_voting_thresholds ; pool voting thresholds
#   , ? 26: drep_voting_thresholds ; DRep voting thresholds
#   , ? 27: uint                   ; min committee size
#   , ? 28: epoch                  ; committee term limit
#   , ? 29: epoch                  ; governance action validity period
#   , ? 30: coin                   ; governance action deposit
#   , ? 31: coin                   ; DRep deposit
#   , ? 32: epoch                  ; DRep inactivity period
#   , ? 33: nonnegative_interval   ; MinFee RefScriptCostPerByte
#   }
# Note: CSL uses unit_interval in place of nonnegative_interval
protocol_param_update:
  type: struct
  fields:
    - id: 0
      key: minfee_a
      value: bignum
      optional: true
    - id: 1
      key: minfee_b
      value: bignum
      optional: true
    - id: 2
      key: max_block_body_size
      value: number
      optional: true
    - id: 3
      key: max_tx_size
      value: number
      optional: true
    - id: 4
      key: max_block_header_size
      value: number
      optional: true
    - id: 5
      key: key_deposit
      value: bignum
      optional: true
    - id: 6
      key: pool_deposit
      value: bignum
      optional: true
    - id: 7
      key: max_epoch
      value: number
      optional: true
    - id: 8
      key: n_opt
      value: number
      optional: true
    - id: 9
      key: pool_pledge_influence
      value: UnitInterval
      optional: true
    - id: 10
      key: expansion_rate
      value: UnitInterval
      optional: true
    - id: 11
      key: treasury_growth_rate
      value: UnitInterval
      optional: true
    - id: 16
      key: min_pool_cost
      value: bignum
      optional: true
    - id: 17
      key: ada_per_utxo_byte
      value: bignum
      optional: true
    - id: 18
      key: costmdls
      value: Costmdls
      optional: true
    - id: 19
      key: execution_costs
      value: ExUnitPrices
      optional: true
    - id: 20
      key: max_tx_ex_units
      value: ExUnits
      optional: true
    - id: 21
      key: max_block_ex_units
      value: ExUnits
      optional: true
    - id: 22
      key: max_value_size
      value: number
      optional: true
    - id: 23
      key: collateral_percentage
      value: number
      optional: true
    - id: 24
      key: max_collateral_inputs
      value: number
      optional: true
    - id: 25
      key: pool_voting_thresholds
      value: PoolVotingThresholds
      optional: true
    - id: 26
      key: drep_voting_thresholds
      value: DrepVotingThresholds
      optional: true
    - id: 27
      key: min_committee_size
      value: number
      optional: true
    - id: 28
      key: committee_term_limit
      value: number
      optional: true
    - id: 29
      key: governance_action_validity_period
      value: number
      optional: true
    - id: 30
      key: governance_action_deposit
      value: bignum
      optional: true
    - id: 31
      key: drep_deposit
      value: bignum
      optional: true
    - id: 32
      key: drep_inactivity_period
      value: number
      optional: true
    - id: 33
      key: script_cost_per_byte
      value: UnitInterval
      optional: true

# pool_voting_thresholds =
#   [ unit_interval ; motion no confidence
#   , unit_interval ; committee normal
#   , unit_interval ; committee no confidence
#   , unit_interval ; hard fork initiation
#   , unit_interval ; security relevant parameter voting threshold
#   ]
PoolVotingThresholds:
  type: record
  fields:
    - key: motion_no_confidence
      value: UnitInterval
    - key: committee_normal
      value: UnitInterval
    - key: committee_no_confidence
      value: UnitInterval
    - key: hard_fork_initiation
      value: UnitInterval
    - key: security_relevant_threshold
      value: UnitInterval

# drep_voting_thresholds =
#   [ unit_interval ; motion no confidence
#   , unit_interval ; committee normal
#   , unit_interval ; committee no confidence
#   , unit_interval ; update constitution
#   , unit_interval ; hard fork initiation
#   , unit_interval ; PP network group
#   , unit_interval ; PP economic group
#   , unit_interval ; PP technical group
#   , unit_interval ; PP governance group
#   , unit_interval ; treasury withdrawal
#   ]
DrepVotingThresholds:
  type: record
  fields:
    - key: motion_no_confidence
      value: UnitInterval
    - key: committee_normal
      value: UnitInterval
    - key: committee_no_confidence
      value: UnitInterval
    - key: update_constitution
      value: UnitInterval
    - key: hard_fork_initiation
      value: UnitInterval
    - key: pp_network_group
      value: UnitInterval
    - key: pp_economic_group
      value: UnitInterval
    - key: pp_technical_group
      value: UnitInterval
    - key: pp_governance_group
      value: UnitInterval
    - key: treasury_withdrawal
      value: UnitInterval

# transaction_witness_set =
#   { ? 0: nonempty_set<vkeywitness>
#   , ? 1: nonempty_set<native_script>
#   , ? 2: nonempty_set<bootstrap_witness>
#   , ? 3: nonempty_set<plutus_v1_script>
#   , ? 4: nonempty_set<plutus_data>
#   , ? 5: redeemers
#   , ? 6: nonempty_set<plutus_v2_script>
#   , ? 7: nonempty_set<plutus_v3_script>
#   }
TransactionWitnessSet:
  type: struct
  fields:
    - id: 0
      key: vkeys
      value: Vkeywitnesses
      optional: true
    - id: 1
      key: native_scripts
      value: NativeScripts
      optional: true
    - id: 2
      key: bootstraps
      value: BootstrapWitnesses
      optional: true
    - id: 3
      key: plutus_scripts_v1
      value: PlutusScripts
      optional: true
    - id: 4
      key: plutus_data
      value: PlutusList
      optional: true
    - id: 5
      key: redeemers
      value: Redeemers
      optional: true
    - id: 6
      key: plutus_scripts_v2
      value: PlutusScripts
      optional: true
    - id: 7
      key: plutus_scripts_v3
      value: PlutusScripts
      optional: true

Vkeywitnesses:
  type: set
  item: Vkeywitness

NativeScripts:
  type: array
  item: NativeScript

BootstrapWitnesses:
  type: array
  item: BootstrapWitness

PlutusScripts:
  type: array
  item: bytes

PlutusList:
  type: set
  item: PlutusData

# ; The real type of  plutus_v1_script, plutus_v2_script and plutus_v3_script is bytes.
# ; However, because we enforce uniqueness when many scripts are supplied,
# ; we need to hack around for tests in order to avoid generating duplicates,
# ; since the cddl tool we use for roundtrip testing doesn't generate distinct collections.
# plutus_v1_script = distinct<bytes>
# plutus_v2_script = distinct<bytes>
# plutus_v3_script = distinct<bytes>

# plutus_data =
#     constr<plutus_data>
#   / { * plutus_data => plutus_data }
#   / [ * plutus_data ]
#   / big_int
#   / bounded_bytes
# TODO: Custom

# big_int = int / big_uint / big_nint
# big_uint = #6.2(bounded_bytes)
# big_nint = #6.3(bounded_bytes)

# constr<a> =
#     #6.121([* a])
#   / #6.122([* a])
#   / #6.123([* a])
#   / #6.124([* a])
#   / #6.125([* a])
#   / #6.126([* a])
#   / #6.127([* a])
#   ; similarly for tag range: 6.128 .. 6.140 inclusive
#   / #6.102([uint, [* a]])
#   TODO: Custom

# ; Flat Array support is included for backwards compatibility and will be removed in the next era.
# ; It is recommended for tools to adopt using a Map instead of Array going forward.
# redeemers =
#   [ + [ tag: redeemer_tag, index: uint, data: plutus_data, ex_units: ex_units ] ]
#   / { + [ tag: redeemer_tag, index: uint ] => [ data: plutus_data, ex_units: ex_units ] }
#   TODO: Custom

# redeemer_tag =
#     0 ; Spending
#   / 1 ; Minting
#   / 2 ; Certifying
#   / 3 ; Rewarding
#   / 4 ; Voting
#   / 5 ; Proposing
RedeemerTag:
  type: enum
  values:
    - name: spending
      value: 0
    - name: minting
      value: 1
    - name: certifying
      value: 2
    - name: rewarding
      value: 3
    - name: voting
      value: 4
    - name: proposing
      value: 5

# ex_units = [mem: uint, steps: uint]
ExUnits:
  type: record
  fields:
    - key: mem
      value: bignum
    - key: steps
      value: bignum

# ex_unit_prices =
#   [ mem_price: nonnegative_interval, step_price: nonnegative_interval ]
# Note: CSL uses unit_interval in place of nonnegative_interval
ExUnitPrices:
  type: record
  fields:
    - key: mem_price
      value: UnitInterval
    - key: step_price
      value: UnitInterval

# language = 0 ; Plutus v1
#          / 1 ; Plutus v2
#          / 2 ; Plutus v3
Language:
  type: enum
  values:
    - name: plutus_v1
      value: 0
    - name: plutus_v2
      value: 1
    - name: plutus_v3
      value: 2

# potential_languages = 0 .. 255
# potential_languages:
#   type: uint
#   value:
#     min: 0
#     max: 255

# ; The format for costmdls is flexible enough to allow adding Plutus built-ins and language
# ; versions in the future.
# ;
# costmdls =
#   { ? 0 : [ 166* int ] ; Plutus v1, only 166 integers are used, but more are accepted (and ignored)
#   , ? 1 : [ 175* int ] ; Plutus v2, only 175 integers are used, but more are accepted (and ignored)
#   , ? 2 : [ 233* int ] ; Plutus v3, only 233 integers are used, but more are accepted (and ignored)
#   , ? 3 : [ int ] ; Any 8-bit unsigned number can be used as a key.
#   }
#   TODO: Rewrite as custom
#         CostMdls is Map<Language, CostModel>
#         CostModel is custom Vec<Int>:
#           get(operation): self[operation]
#           set(operation, cost): fill zero from self.len to operation; self[operation] = cost
# TODO: Custom

# transaction_metadatum =
#     { * transaction_metadatum => transaction_metadatum }
#   / [ * transaction_metadatum ]
#   / int
#   / bytes .size (0..64)
#   / text .size (0..64)
#   TODO: Custom

# transaction_metadatum_label = uint

# metadata = { * transaction_metadatum_label => transaction_metadatum }
GeneralTransactionMetadata:
  type: map
  key: bignum
  value: TransactionMetadatum

# auxiliary_data =
#   metadata ; Shelley
#   / [ transaction_metadata: metadata ; Shelley-ma
#     , auxiliary_scripts: [ * native_script ]
#     ]
#   / #6.259({ ? 0 => metadata         ; Alonzo and beyond
#       , ? 1 => [ * native_script ]
#       , ? 2 => [ * plutus_v1_script ]
#       , ? 3 => [ * plutus_v2_script ]
#       , ? 4 => [ * plutus_v3_script ]
#       })
AuxiliaryData:
  type: struct
  fields:
    - id: 0
      key: metadata
      value: GeneralTransactionMetadata
    - id: 1
      key: native_scripts
      value: NativeScripts
    - id: 2
      key: plutus_scripts_v1
      value: PlutusScripts
    - id: 3
      key: plutus_scripts_v2
      value: PlutusScripts
    - id: 4
      key: plutus_scripts_v3
      value: PlutusScripts

# vkeywitness = [ $vkey, $signature ]
Vkeywitness:
  type: record
  fields:
    - key: vkey
      value: Vkey
    - key: signature
      value: Ed25519Signature

# bootstrap_witness =
#   [ public_key : $vkey
#   , signature  : $signature
#   , chain_code : bytes .size 32
#   , attributes : bytes
#   ]
BootstrapWitness:
  type: record
  fields:
    - key: vkey
      value: VKey
    - key: signature
      value: Ed25519Signature
    - key: chain_code
      value: bytes
    - key: attributes
      value: bytes

# native_script =
#   [ script_pubkey
#   // script_all
#   // script_any
#   // script_n_of_k
#   // invalid_before
#      ; Timelock validity intervals are half-open intervals [a, b).
#      ; This field specifies the left (included) endpoint a.
#   // invalid_hereafter
#      ; Timelock validity intervals are half-open intervals [a, b).
#      ; This field specifies the right (excluded) endpoint b.
#   ]
# script_pubkey = (0, addr_keyhash)
# script_all = (1, [ * native_script ])
# script_any = (2, [ * native_script ])
# script_n_of_k = (3, n: uint, [ * native_script ])
# invalid_before = (4, uint)
# invalid_hereafter = (5, uint)
NativeScript:
  type: tagged_record
  variants:
    - name: script_pubkey
      tag: 0
      value: ScriptPubkey
    - name: script_all
      tag: 1
      value: ScriptAll
    - name: script_any
      tag: 2
      value: ScriptAny
    - name: script_n_of_k
      tag: 3
      value: ScriptNOfK
    - name: timelock_start
      tag: 4
      value: TimelockStart
    - name: timelock_expiry
      tag: 5
      value: TimelockExpiry

ScriptPubkey:
  type: record_fragment
  fields:
    - key: addr_keyhash
      value: Ed25519KeyHash

ScriptAll:
  type: record_fragment
  fields:
    - key: native_scripts
      value: NativeScripts

ScriptAny:
  type: record_fragment
  fields:
    - key: native_scripts
      value: NativeScripts

ScriptNOfK:
  type: record_fragment
  fields:
    - key: n
      value: number
    - key: native_scripts
      value: NativeScripts

TimelockStart:
  type: record_fragment
  fields:
    - key: slot
      value: bignum

TimelockExpiry:
  type: record_fragment
  fields:
    - key: slot
      value: bignum

# coin = uint

# multiasset<a> = { + policy_id => { + asset_name => a } }
# TODO: Custom

# policy_id = scripthash

# asset_name = bytes .size (0..32)
AssetName:
  type: newtype
  item: bytes
  constraints:
    len:
      max: 32

# negInt64 = -9223372036854775808 .. -1

# posInt64 = 1 .. 9223372036854775807

# nonZeroInt64 = negInt64 / posInt64 ; this is the same as the current int64 definition but without zero

# positive_coin = 1 .. 18446744073709551615

# value = coin / [coin, multiasset<positive_coin>]
# TODO: Custom

# mint = multiasset<nonZeroInt64>
# TODO: Custom

# int64 = -9223372036854775808 .. 9223372036854775807

# network_id = 0 / 1
NetworkId:
  type: enum
  values:
    - name: mainnet
      value: 0
    - name: testnet
      value: 1

# epoch = uint

# addr_keyhash           = $hash28
# pool_keyhash           = $hash28
# vrf_keyhash           = $hash32
# auxiliary_data_hash   = $hash32
# pool_metadata_hash    = $hash32

# ; To compute a script hash, note that you must prepend
# ; a tag to the bytes of the script before hashing.
# ; The tag is determined by the language.
# ; The tags in the Conway era are:
# ;   "\x00" for multisig scripts
# ;   "\x01" for Plutus V1 scripts
# ;   "\x02" for Plutus V2 scripts
# ;   "\x03" for Plutus V3 scripts
# scripthash            = $hash28

# datum_hash = $hash32

# data = #6.24(bytes .cbor plutus_data)

# datum_option = [ 0, $hash32 // 1, data ]
DataOption:
  type: tagged_record
  variants:
    - name: hash
      tag: 0
      value: DataHash
    - name: data
      tag: 1
      value: PlutusData # TODO: Encode as #6.24(bytes)

# script_ref = #6.24(bytes .cbor script)
# TODO: Custom

# script = [ 0, native_script // 1, plutus_v1_script // 2, plutus_v2_script // 3, plutus_v3_script ]
ScriptRef:
  type: tagged_record
  variants:
    - name: native_script
      tag: 0
      value: NativeScript
    - name: plutus_script_v1
      tag: 1
      value: bytes
    - name: plutus_script_v2
      tag: 2
      value: bytes
    - name: plutus_script_v3
      tag: 3
      value: bytes

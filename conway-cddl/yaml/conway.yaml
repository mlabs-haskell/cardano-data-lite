# block =
#   [ header
#   , transaction_bodies         : [* transaction_body]
#   , transaction_witness_sets   : [* transaction_witness_set]
#   , auxiliary_data_set         : {* transaction_index => auxiliary_data }
#   , invalid_transactions       : [* transaction_index ]
#   ]; Valid blocks must also satisfy the following two constraints:
#    ; 1) the length of transaction_bodies and transaction_witness_sets
#    ;    must be the same
#    ; 2) every transaction_index must be strictly smaller than the
#    ;    length of transaction_bodies
Block:
  type: record
  methods:
    new: null
  extra_methods: |
    static new(
      header: Header,
      transaction_bodies: TransactionBodies,
      transaction_witness_sets: TransactionWitnessSets,
      auxiliary_data_set: AuxiliaryDataSet,
      invalid_transactions: Uint32Array
    ): Block {
      return new Block(
        header,
        transaction_bodies,
        transaction_witness_sets,
        auxiliary_data_set,
        new InvalidTransactions(invalid_transactions)
      );
    }

    invalid_transactions(): Uint32Array {
      return this.inner_invalid_transactions().as_uint32Array();
    }

    set_invalid_transactions(invalid_transactions: Uint32Array) {
      this._inner_invalid_transactions = new InvalidTransactions(invalid_transactions);
    }
  fields:
    - name: header
      type: Header
    - name: transaction_bodies
      type: TransactionBodies
    - name: transaction_witness_sets
      type: TransactionWitnessSets
    - name: auxiliary_data_set
      type: AuxiliaryDataSet
    - name: inner_invalid_transactions
      type: InvalidTransactions

TransactionBodies:
  type: array
  item: TransactionBody

TransactionWitnessSets:
  type: array
  item: TransactionWitnessSet

AuxiliaryDataSet:
  type: map
  key: number
  value: AuxiliaryData
  extra_methods: |
    indices(): Uint32Array {
      let indices = new Uint32Array(this._items.length);
      for(let i = 0; i < this._items.length; i++) {
        let item = this._items[i];
        let key = item[0];
        indices[i] = key;
      }
      return indices;
    }

# no item type means that it is encoded as a Uint32Array
InvalidTransactions:
  type: array
  extra_methods: |
    as_uint32Array(): Uint32Array {
      return this.items;
    }

# transaction =
#   [ transaction_body
#   , transaction_witness_set
#   , bool
#   , auxiliary_data / null
#   ]
Transaction:
  type: record
  fields:
    - name: body
      type: TransactionBody
    - name: witness_set
      type: TransactionWitnessSet
    - name: is_valid
      type: boolean
    - name: auxiliary_data
      type: AuxiliaryData
      nullable: true
  methods:
    new: null
  extra_methods: |
    static new(
      body: TransactionBody,
      witness_set: TransactionWitnessSet,
      auxiliary_data: AuxiliaryData
    ): Transaction {
      return new Transaction(
        body,
        witness_set,
        true,
        auxiliary_data
      );
    }

# transaction_index = uint .size 2

# header =
#   [ header_body
#   , body_signature : $kes_signature
#   ]
Header:
  type: record
  fields:
    - name: header_body
      type: HeaderBody
    - name: body_signature
      type: KESSignature

# header_body =
#   [ block_number     : uint
#   , slot             : uint
#   , prev_hash        : $hash32 / null
#   , issuer_vkey      : $vkey
#   , vrf_vkey         : $vrf_vkey
#   , vrf_result       : $vrf_cert ; replaces nonce_vrf and leader_vrf
#   , block_body_size  : uint
#   , block_body_hash  : $hash32 ; merkle triple root
#   , operational_cert
#   , protocol_version
#   ]
HeaderBody:
  type: record
  fields:
    - name: block_number
      type: number
    - name: slot
      type: BigNum
    - name: prev_hash
      type: BlockHash
      nullable: true
    - name: issuer_vkey
      type: Vkey
    - name: vrf_vkey
      type: VRFVKey
    - name: vrf_result
      type: VRFCert
    - name: block_body_size
      type: number
    - name: block_body_hash
      type: BlockHash
    - name: operational_cert
      type: OperationalCert
    - name: protocol_version
      type: ProtocolVersion
  methods:
    slot: slot_bignum
    new: new_headerbody
  extra_methods: |
    slot(): number  {
      return this.slot_bignum()._to_number();
    }

    static new(
      block_number: number,
      slot: number,
      prev_hash: BlockHash | undefined,
      issuer_vkey: Vkey,
      vrf_vkey: VRFVKey,
      vrf_result: VRFCert,
      block_body_size: number,
      block_body_hash: BlockHash,
      operational_cert: OperationalCert,
      protocol_version: ProtocolVersion
    ): HeaderBody {
      return new HeaderBody(
        block_number,
        BigNum._from_number(slot),
        prev_hash,
        issuer_vkey,
        vrf_vkey,
        vrf_result,
        block_body_size,
        block_body_hash,
        operational_cert,
        protocol_version,
      );
    }

# operational_cert =
#   [ hot_vkey        : $kes_vkey
#   , sequence_number : uint
#   , kes_period      : uint
#   , sigma           : $signature
#   ]
OperationalCert:
  type: record
  fields:
    - name: hot_vkey
      type: KESVKey
    - name: sequence_number
      type: number
    - name: kes_period
      type: number
    - name: sigma
      type: Ed25519Signature

# next_major_protocol_version = 10
# major_protocol_version = 1..next_major_protocol_version

# protocol_version = [(major_protocol_version, uint)]
ProtocolVersion:
  type: record
  fields:
    - name: major
      type: number
    - name: minor
      type: number

# transaction_body =
#   { 0 : set<transaction_input>             ; inputs
#   , 1 : [* transaction_output]
#   , 2 : coin                               ; fee
#   , ? 3 : uint                             ; time to live
#   , ? 4 : certificates
#   , ? 5 : withdrawals
#   , ? 7 : auxiliary_data_hash
#   , ? 8 : uint                             ; validity interval start
#   , ? 9 : mint
#   , ? 11 : script_data_hash
#   , ? 13 : nonempty_set<transaction_input> ; collateral inputs
#   , ? 14 : required_signers
#   , ? 15 : network_id
#   , ? 16 : transaction_output              ; collateral return
#   , ? 17 : coin                            ; total collateral
#   , ? 18 : nonempty_set<transaction_input> ; reference inputs
#   , ? 19 : voting_procedures               ; New; Voting procedures
#   , ? 20 : proposal_procedures             ; New; Proposal procedures
#   , ? 21 : coin                            ; New; current treasury value
#   , ? 22 : positive_coin                   ; New; donation
#   }
TransactionBody:
  type: struct
  fields:
    - id: 0
      name: inputs
      type: TransactionInputs
    - id: 1
      name: outputs
      type: TransactionOutputs
    - id: 2
      name: fee
      type: BigNum
    - id: 3
      name: ttl
      type: BigNum
      optional: true
    - id: 4
      name: certs
      type: Certificates
      optional: true
    - id: 5
      name: withdrawals
      type: Withdrawals
      optional: true
    - id: 7
      name: auxiliary_data_hash
      type: AuxiliaryDataHash
      optional: true
    - id: 8
      name: validity_start_interval
      type: BigNum
      optional: true
    - id: 9
      name: mint
      type: Mint
      optional: true
    - id: 11
      name: script_data_hash
      type: ScriptDataHash
      optional: true
    - id: 13
      name: collateral
      type: TransactionInputs
      optional: true
    - id: 14
      name: required_signers
      type: Ed25519KeyHashes
      optional: true
    - id: 15
      name: network_id
      type: NetworkId
      optional: true
    - id: 16
      name: collateral_return
      type: TransactionOutput
      optional: true
    - id: 17
      name: total_collateral
      type: BigNum
      optional: true
    - id: 18
      name: reference_inputs
      type: TransactionInputs
      optional: true
    - id: 19
      name: voting_procedures
      type: VotingProcedures
      optional: true
    - id: 20
      name: voting_proposals
      type: VotingProposals
      optional: true
    - id: 21
      name: current_treasury_value
      type: BigNum
      optional: true
    - id: 22
      name: donation
      type: BigNum
      optional: true
  methods:
    ttl: ttl_bignum
    validity_start_interval: validity_start_interval_bignum
    set_validity_start_interval: set_validity_start_interval_bignum
    new: null
  extra_methods: |
    ttl(): number | undefined {
      return this.ttl_bignum()?._to_number();
    }

    remove_ttl(): void {
      this.set_ttl(undefined);
    }

    validity_start_interval(): number | undefined {
      return this.validity_start_interval_bignum()?._to_number();
    }

    set_validity_start_interval(validity_start_interval: number) {
      return this.set_validity_start_interval_bignum(
        BigNum._from_number(validity_start_interval)
      );
    }

    static new(
      inputs: TransactionInputs,
      outputs: TransactionOutputs,
      fee: BigNum,
      path: string[] = ['TransactionBody'],
      ttl?: number
    ): TransactionBody {
      return new TransactionBody(
        inputs.clone([...path, "TransactionInputs"]),
        outputs.clone([...path, "TransactionOutputs"]),
        fee,
        ttl != null ? BigNum._from_number(ttl) : undefined,
        undefined,
        undefined,
        undefined,
        undefined,
        undefined,
        undefined,
        undefined,
        undefined,
        undefined,
        undefined,
        undefined,
        undefined,
        undefined,
        undefined,
        undefined,
        undefined,
      );
    }

    static new_tx_body(
      inputs: TransactionInputs,
      outputs: TransactionOutputs,
      fee: BigNum,
      path: string[]
    ): TransactionBody {
      return TransactionBody.new(inputs, outputs, fee, path, undefined);
    }

TransactionInputs:
  type: set
  item: TransactionInput

TransactionOutputs:
  type: array
  item: TransactionOutput

Certificates:
  type: set
  item: Certificate

Ed25519KeyHashes:
  type: set
  item: Ed25519KeyHash

# voting_procedure =
#   [ vote
#   , anchor / null
#   ]
VotingProcedure:
  type: record
  fields:
    - name: vote
      type: VoteKind
    - name: anchor
      type: Anchor
      nullable: true
  methods:
    new: new_with_anchor
  extra_methods: |
    static new(vote: VoteKind): VotingProcedure {
      return new VotingProcedure(vote, undefined);
    }

# proposal_procedure =
#   [ deposit : coin
#   , reward_account
#   , gov_action
#   , anchor
#   ]
VotingProposal:
  type: record
  fields:
    - name: deposit
      type: BigNum
    - name: reward_account
      type: RewardAddress
    - name: governance_action
      type: GovernanceAction
    - name: anchor
      type: Anchor
  methods:
    new: null
  extra_methods: |
    static new(
      governance_action: GovernanceAction,
      anchor: Anchor,
      reward_account: RewardAddress,
      deposit: BigNum
    ): VotingProposal {
      return new VotingProposal(
        deposit,
        reward_account,
        governance_action,
        anchor
      )
    }

# proposal_procedures = nonempty_oset<proposal_procedure>
VotingProposals:
  type: set
  item: VotingProposal

# certificates = nonempty_oset<certificate>
certificates:
  type: set
  item: Certificate

# policy_hash = scripthash

# gov_action =
#   [ parameter_change_action
#   // hard_fork_initiation_action
#   // treasury_withdrawals_action
#   // no_confidence
#   // update_committee
#   // new_constitution
#   // info_action
#   ]
# parameter_change_action = (0, gov_action_id / null, protocol_param_update, policy_hash / null)
# hard_fork_initiation_action = (1, gov_action_id / null, protocol_version)
# treasury_withdrawals_action = (2, { reward_account => coin }, policy_hash / null)
# no_confidence = (3, gov_action_id / null)
# update_committee = (4, gov_action_id / null, set<committee_cold_credential>, { committee_cold_credential => epoch }, unit_interval)
# new_constitution = (5, gov_action_id / null, constitution)
# info_action = 6
GovernanceAction:
  type: tagged_record
  variants:
    - name: parameter_change_action
      tag: 0
      value: ParameterChangeAction
    - name: hard_fork_initiation_action
      tag: 1
      value: HardForkInitiationAction
    - name: treasury_withdrawals_action
      tag: 2
      value: TreasuryWithdrawalsAction
    - name: no_confidence_action
      tag: 3
      value: NoConfidenceAction
    - name: new_committee_action
      value: UpdateCommitteeAction
      tag: 4
    - name: new_constitution_action
      value: NewConstitutionAction
      tag: 5
    - name: info_action
      tag: 6
      value: InfoAction

ParameterChangeAction:
  type: record_fragment
  fields:
    - name: gov_action_id
      type: GovernanceActionId
      nullable: true
    - name: protocol_param_updates
      type: ProtocolParamUpdate
    - name: policy_hash
      type: ScriptHash
      nullable: true
  methods:
    new: new_with_policy_hash_and_action_id
  extra_methods: |
    static new(
      protocol_param_updates: ProtocolParamUpdate
    ): ParameterChangeAction {
      return new ParameterChangeAction(
        undefined,
        protocol_param_updates,
        undefined
      );
    }
    static new_with_action_id(
      gov_action_id: GovernanceActionId,
      protocol_param_updates: ProtocolParamUpdate
    ): ParameterChangeAction {
      return new ParameterChangeAction(
        gov_action_id,
        protocol_param_updates,
        undefined
      );
    }
    static new_with_policy_hash(
      protocol_param_updates: ProtocolParamUpdate,
      policy_hash: ScriptHash
    ): ParameterChangeAction {
      return new ParameterChangeAction(
        undefined,
        protocol_param_updates,
        policy_hash
      );
    }

HardForkInitiationAction:
  type: record_fragment
  fields:
    - name: gov_action_id
      type: GovernanceActionId
      nullable: true
    - name: protocol_version
      type: ProtocolVersion
  methods:
    new: new_with_action_id
  extra_methods: |
    static new(protocol_version: ProtocolVersion): HardForkInitiationAction {
      return new HardForkInitiationAction(undefined, protocol_version);
    }

TreasuryWithdrawalsAction:
  type: record_fragment
  fields:
    - name: withdrawals
      type: TreasuryWithdrawals
    - name: policy_hash
      type: ScriptHash
      nullable: true
  methods:
    new: new_with_policy_hash
  extra_methods: |
    static new(withdrawals: TreasuryWithdrawals): TreasuryWithdrawalsAction {
      return new TreasuryWithdrawalsAction(withdrawals, undefined);
    }

NoConfidenceAction:
  type: record_fragment
  fields:
    - name: gov_action_id
      type: GovernanceActionId
      nullable: true
  methods:
    new: new_with_action_id
  extra_methods: |
    static new(): NoConfidenceAction {
      return new NoConfidenceAction(undefined);
    }

NewConstitutionAction:
  type: record_fragment
  fields:
    - name: gov_action_id
      type: GovernanceActionId
      nullable: true
    - name: constitution
      type: Constitution
  methods:
    new: new_with_action_id
  extra_methods: |
    static new(constitution: Constitution): NewConstitutionAction {
      return new NewConstitutionAction(undefined, constitution);
    }

InfoAction:
  type: record_fragment
  fields: []

Credentials:
  type: set
  item: Credential

# constitution =
#   [ anchor
#   , scripthash / null
#   ]
Constitution:
  type: record
  fields:
    - name: anchor
      type: Anchor
    - name: script_hash
      type: ScriptHash
      nullable: true
  methods:
    new: null
  extra_methods: |
    static new(anchor: Anchor): Constitution {
      return new Constitution(anchor, undefined);
    }
    static new_with_script_hash(anchor: Anchor, scripthash: ScriptHash | undefined) {
      return new Constitution(anchor, scripthash);
    }

Voters:
  type: array
  item: Voter

# anchor =
#   [ anchor_url       : url
#   , anchor_data_hash : $hash32
#   ]
Anchor:
  type: record
  fields:
    - name: url
      type: URL
    - name: anchor_data_hash
      type: AnchorDataHash

# ; no - 0
# ; yes - 1
# ; abstain - 2
# vote = 0 .. 2
VoteKind:
  type: enum_simple
  values:
    - name: No
      value: 0
    - name: Yes
      value: 1
    - name: Abstain
      value: 2

# gov_action_id =
#   [ transaction_id   : $hash32
#   , gov_action_index : uint
#   ]
GovernanceActionId:
  type: record
  fields:
    - name: transaction_id
      type: TransactionHash
    - name: index
      type: number

GovernanceActionIds:
  type: array
  item: GovernanceActionId

# required_signers = nonempty_set<addr_keyhash>
# Replaced by Ed25519KeyHashes. See TransactionBody

# transaction_input = [ transaction_id : $hash32
#                     , index : uint
#                     ]
TransactionInput:
  type: record
  fields:
    - name: transaction_id
      type: TransactionHash
    - name: index
      type: number

# ; Both of the Alonzo and Babbage style TxOut formats are equally valid
# ; and can be used interchangeably
# transaction_output = pre_babbage_transaction_output / post_alonzo_transaction_output
TransactionOutput:
  type: union
  variants:
    - tag: 0
      peek_type: array
      name: pre_babbage_transaction_output
      type: PreBabbageTransactionOutput
    - tag: 1
      peek_type: map
      name: post_alonzo_transaction_output
      type: PostAlonzoTransactionOutput
  methods:
    new: null
  extra_methods: |
    static new(address: Address, amount: Value): TransactionOutput {
      const post_alonzo_transaction_output = new PostAlonzoTransactionOutput(address, amount, undefined, undefined);
      return new TransactionOutput({kind: 1, value: post_alonzo_transaction_output});
    }

    address(): Address {
      return this.variant.value.address();
    }

    set_address(address: Address): void {
      return this.variant.value.set_address(address);
    }

    amount(): Value {
      return this.variant.value.amount();
    }

    set_amount(amount: Value): void {
      this.variant.value.set_amount(amount);
    }

    data_hash(): DataHash | undefined {
      switch (this.variant.kind) {
        case 0:
          return this.as_pre_babbage_transaction_output().datum_hash();
        case 1:
          const opt = this.as_post_alonzo_transaction_output().datum_option();
          return opt?.as_hash();
      }
    }

    set_data_hash(data_hash: DataHash | undefined): void {
      switch (this.variant.kind) {
        case 0:
          let bto = this.as_pre_babbage_transaction_output();
          bto.set_datum_hash(data_hash);
          this.variant = { kind: 0, value: bto };
          break;
        case 1:
          let ato = this.as_post_alonzo_transaction_output();
          if (data_hash) {
            ato.set_datum_option(DataOption.new_hash(data_hash));
          } else {
            ato.set_datum_option(undefined);
          }
          this.variant = { kind: 1, value: ato };
          break;
      }
    }

    datum_option(): DataOption | undefined {
      switch (this.variant.kind) {
        case 0:
          return undefined;
        case 1:
          return this.as_post_alonzo_transaction_output().datum_option();
      }
    }

    set_datum_option(datum_option: DataOption | undefined): void {
      switch (this.variant.kind) {
        case 0:
          if (datum_option) {
            const pbt = this.as_pre_babbage_transaction_output()
            this.variant = { kind: 1, value: PostAlonzoTransactionOutput.new(pbt.address(), pbt.amount(), datum_option, undefined) };
          }
        case 1:
          let pat = this.as_post_alonzo_transaction_output();
          pat.set_datum_option(datum_option);
          this.variant = { kind: 1, value: pat };
      }
    }

    script_ref(): ScriptRef | undefined {
      switch (this.variant.kind) {
        case 0:
          return undefined;
        case 1:
          return this.as_post_alonzo_transaction_output().script_ref();
      }
    }

    set_script_ref(script_ref: ScriptRef | undefined): void {
      switch (this.variant.kind) {
        case 0:
          if (ScriptRef) {
            const pbt = this.as_pre_babbage_transaction_output()
            this.variant = { kind: 1, value: PostAlonzoTransactionOutput.new(pbt.address(), pbt.amount(), undefined, script_ref) };
          }
        case 1:
          let pat = this.as_post_alonzo_transaction_output();
          pat.set_script_ref(script_ref);
          this.variant = { kind: 1, value: pat };
      }
    }

# post_alonzo_transaction_output =
#   { 0 : address
#   , 1 : value
#   , ? 2 : datum_option ; datum option
#   , ? 3 : script_ref   ; script reference
#   }
PostAlonzoTransactionOutput:
  type: struct
  fields:
    - id: 0
      name: address
      type: Address
    - id: 1
      name: amount
      type: Value
    - id: 2
      name: datum_option
      type: DataOption
      optional: true
    - id: 3
      name: script_ref
      type: ScriptRef
      optional: true

# pre_babbage_transaction_output =
#   [ address
#   , amount : value
#   , ? datum_hash : $hash32
#   ]
#
PreBabbageTransactionOutput:
  type: record
  fields:
    - name: address
      type: Address
    - name: amount
      type: Value
    - name: datum_hash
      type: DataHash
      optional: true


# script_data_hash = $hash32
# ; This is a hash of data which may affect evaluation of a script.
# ; This data consists of:
# ;   - The redeemers from the transaction_witness_set (the value of field 5).
# ;   - The datums from the transaction_witness_set (the value of field 4).
# ;   - The value in the costmdls map corresponding to the script's language
# ;     (in field 18 of protocol_param_update.)
# ; (In the future it may contain additional protocol parameters.)
# ;
# ; Since this data does not exist in contiguous form inside a transaction, it needs
# ; to be independently constructed by each recipient.
# ;
# ; The bytestring which is hashed is the concatenation of three things:
# ;   redeemers || datums || language views
# ; The redeemers are exactly the data present in the transaction witness set.
# ; Similarly for the datums, if present. If no datums are provided, the middle
# ; field is omitted (i.e. it is the empty/null bytestring).
# ;
# ; language views CDDL:
# ; { * language => script_integrity_data }
# ;
# ; This must be encoded canonically, using the same scheme as in
# ; RFC7049 section 3.9:
# ;  - Maps, strings, and bytestrings must use a definite-length encoding
# ;  - Integers must be as small as possible.
# ;  - The expressions for map length, string length, and bytestring length
# ;    must be as short as possible.
# ;  - The keys in the map must be sorted as follows:
# ;     -  If two keys have different lengths, the shorter one sorts earlier.
# ;     -  If two keys have the same length, the one with the lower value
# ;        in (byte-wise) lexical order sorts earlier.
# ;
# ; For PlutusV1 (language id 0), the language view is the following:
# ;   - the value of costmdls map at key 0 (in other words, the script_integrity_data)
# ;     is encoded as an indefinite length list and the result is encoded as a bytestring.
# ;     (our apologies)
# ;     For example, the script_integrity_data corresponding to the all zero costmodel for V1
# ;     would be encoded as (in hex):
# ;     58a89f00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000ff
# ;   - the language ID tag is also encoded twice. first as a uint then as
# ;     a bytestring. (our apologies)
# ;     Concretely, this means that the language version for V1 is encoded as
# ;     4100 in hex.
# ; For PlutusV2 (language id 1), the language view is the following:
# ;   - the value of costmdls map at key 1 is encoded as an definite length list.
# ;     For example, the script_integrity_data corresponding to the all zero costmodel for V2
# ;     would be encoded as (in hex):
# ;     98af0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
# ;   - the language ID tag is encoded as expected.
# ;     Concretely, this means that the language version for V2 is encoded as
# ;     01 in hex.
# ; For PlutusV3 (language id 2), the language view is the following:
# ;   - the value of costmdls map at key 2 is encoded as a definite length list.
# ;
# ; Note that each Plutus language represented inside a transaction must have
# ; a cost model in the costmdls protocol parameter in order to execute,
# ; regardless of what the script integrity data is.
# ;
# ; Finally, note that in the case that a transaction includes datums but does not
# ; include the redeemers field, the script data format becomes (in hex):
# ; [ 80 | datums | A0 ]
# ; corresponding to a CBOR empty list and an empty map.
# ; Note that a transaction might include the redeemers field and  it to the
# ; empty map, in which case the user supplied encoding of the empty map is used.
# ;
# ; address = bytes
# ; reward_account = bytes
#
# ; address format:
# ; [ 8 bit header | payload ];
# ;
# ; shelley payment addresses:
# ; bit 7: 0
# ; bit 6: base/other
# ; bit 5: pointer/enterprise [for base: stake cred is keyhash/scripthash]
# ; bit 4: payment cred is keyhash/scripthash
# ; bits 3-0: network id
# ;
# ; reward addresses:
# ; bits 7-5: 111
# ; bit 4: credential is keyhash/scripthash
# ; bits 3-0: network id
# ;
# ; byron addresses:
# ; bits 7-4: 1000
#
# ; 0000: base address: keyhash28,keyhash28
# ; 0001: base address: scripthash28,keyhash28
# ; 0010: base address: keyhash28,scripthash28
# ; 0011: base address: scripthash28,scripthash28
# ; 0100: pointer address: keyhash28, 3 variable length uint
# ; 0101: pointer address: scripthash28, 3 variable length uint
# ; 0110: enterprise address: keyhash28
# ; 0111: enterprise address: scripthash28
# ; 1000: byron address
# ; 1110: reward account: keyhash28
# ; 1111: reward account: scripthash28
# ; 1001 - 1101: future formats
# script_data_hash:
#   type: hash32

# certificate =
#   [ stake_registration
#   // stake_deregistration
#   // stake_delegation
#   // pool_registration
#   // pool_retirement
#   // reg_cert
#   // unreg_cert
#   // vote_deleg_cert
#   // stake_vote_deleg_cert
#   // stake_reg_deleg_cert
#   // vote_reg_deleg_cert
#   // stake_vote_reg_deleg_cert
#   // auth_committee_hot_cert
#   // resign_committee_cold_cert
#   // reg_drep_cert
#   // unreg_drep_cert
#   // update_drep_cert
#   ]
#
# stake_registration = (0, stake_credential) ; to be deprecated in era after Conway
# stake_deregistration = (1, stake_credential) ; to be deprecated in era after Conway
# stake_delegation = (2, stake_credential, pool_keyhash)
#
# ; POOL
# pool_registration = (3, pool_params)
# pool_retirement = (4, pool_keyhash, epoch)
#
# ; numbers 5 and 6 used to be the Genesis and MIR certificates respectively,
# ; which were deprecated in Conway
#
# ; DELEG
# reg_cert = (7, stake_credential, coin)
# unreg_cert = (8, stake_credential, coin)
# vote_deleg_cert = (9, stake_credential, drep)
# stake_vote_deleg_cert = (10, stake_credential, pool_keyhash, drep)
# stake_reg_deleg_cert = (11, stake_credential, pool_keyhash, coin)
# vote_reg_deleg_cert = (12, stake_credential, drep, coin)
# stake_vote_reg_deleg_cert = (13, stake_credential, pool_keyhash, drep, coin)
#
# ; GOVCERT
# auth_committee_hot_cert = (14, committee_cold_credential, committee_hot_credential)
# resign_committee_cold_cert = (15, committee_cold_credential, anchor / null)
# reg_drep_cert = (16, drep_credential, coin, anchor / null)
# unreg_drep_cert = (17, drep_credential, coin)
# update_drep_cert = (18, drep_credential, anchor / null)
Certificate:
  type: tagged_record
  variants:
    - name: stake_registration
      tag: 0
      value: StakeRegistration
    - name: stake_deregistration
      tag: 1
      value: StakeDeregistration
    - name: stake_delegation
      tag: 2
      value: StakeDelegation
    - name: pool_registration
      tag: 3
      value: PoolRegistration
    - name: pool_retirement
      tag: 4
      value: PoolRetirement
    - name: reg_cert
      tag: 7
      value: RegCert
    - name: unreg_cert
      tag: 8
      value: UnregCert
    - name: vote_delegation
      tag: 9
      value: VoteDelegation
    - name: stake_and_vote_delegation
      tag: 10
      value: StakeAndVoteDelegation
    - name: stake_registration_and_delegation
      tag: 11
      value: StakeRegistrationAndDelegation
    - name: vote_registration_and_delegation
      tag: 12
      value: VoteRegistrationAndDelegation
    - name: stake_vote_registration_and_delegation
      tag: 13
      value: StakeVoteRegistrationAndDelegation
    - name: committee_hot_auth
      tag: 14
      value: CommitteeHotAuth
    - name: committee_cold_resign
      tag: 15
      value: CommitteeColdResign
    - name: drep_registration
      tag: 16
      value: DRepRegistration
    - name: drep_deregistration
      tag: 17
      value: DRepDeregistration
    - name: drep_update
      tag: 18
      value: DRepUpdate

StakeRegistration:
  type: record_fragment
  fields:
    - name: stake_credential
      type: Credential

StakeDeregistration:
  type: record_fragment
  fields:
    - name: stake_credential
      type: Credential

StakeDelegation:
  type: record_fragment
  fields:
    - name: stake_credential
      type: Credential
    - name: pool_keyhash
      type: Ed25519KeyHash

PoolRegistration:
  type: record_fragment_wrapper
  item:
    name: pool_params
    type: PoolParams

PoolRetirement:
  type: record_fragment
  fields:
    - name: pool_keyhash
      type: Ed25519KeyHash
    - name: epoch
      type: number

RegCert:
  type: record_fragment
  fields:
    - name: stake_credential
      type: Credential
    - name: coin
      type: BigNum

UnregCert:
  type: record_fragment
  fields:
    - name: stake_credential
      type: Credential
    - name: coin
      type: BigNum

VoteDelegation:
  type: record_fragment
  fields:
    - name: stake_credential
      type: Credential
    - name: drep
      type: DRep

StakeAndVoteDelegation:
  type: record_fragment
  fields:
    - name: stake_credential
      type: Credential
    - name: pool_keyhash
      type: Ed25519KeyHash
    - name: drep
      type: DRep

StakeRegistrationAndDelegation:
  type: record_fragment
  fields:
    - name: stake_credential
      type: Credential
    - name: pool_keyhash
      type: Ed25519KeyHash
    - name: coin
      type: BigNum

VoteRegistrationAndDelegation:
  type: record_fragment
  fields:
    - name: stake_credential
      type: Credential
    - name: drep
      type: DRep
    - name: coin
      type: BigNum

StakeVoteRegistrationAndDelegation:
  type: record_fragment
  fields:
    - name: stake_credential
      type: Credential
    - name: pool_keyhash
      type: Ed25519KeyHash
    - name: drep
      type: DRep
    - name: coin
      type: BigNum

CommitteeHotAuth:
  type: record_fragment
  fields:
    - name: committee_cold_credential
      type: Credential
    - name: committee_hot_credential
      type: Credential

CommitteeColdResign:
  type: record_fragment
  fields:
    - name: committee_cold_credential
      type: Credential
    - name: anchor
      type: Anchor
      nullable: true
  methods:
    new: null
  extra_methods: |
    static new(committee_cold_credential: Credential): CommitteeColdResign {
      return new CommitteeColdResign(committee_cold_credential, undefined);
    }
    static new_with_anchor(committee_cold_credential: Credential, anchor: Anchor) {
      return new CommitteeColdResign(committee_cold_credential, anchor);
    }

DRepRegistration:
  type: record_fragment
  fields:
    - name: voting_credential
      type: Credential
    - name: coin
      type: BigNum
    - name: anchor
      type: Anchor
      nullable: true
  methods:
    new: null
  extra_methods: |
    static new(voting_credential: Credential, coin: BigNum): DRepRegistration {
      return new DRepRegistration(voting_credential,coin, undefined);
    }
    static new_with_anchor(voting_credential: Credential, coin: BigNum, anchor: Anchor) {
      return new DRepRegistration(voting_credential, coin, anchor);
    }

DRepDeregistration:
  type: record_fragment
  fields:
    - name: drep_credential
      type: Credential
    - name: coin
      type: BigNum

DRepUpdate:
  type: record_fragment
  fields:
    - name: drep_credential
      type: Credential
    - name: anchor
      type: Anchor
      nullable: true
  methods:
    new: null
  extra_methods: |
    static new(drep_credential: Credential): DRepUpdate {
      return new DRepUpdate(drep_credential, undefined);
    }
    static new_with_anchor(drep_credential: Credential, anchor: Anchor) {
      return new DRepUpdate(drep_credential, anchor);
    }

# delta_coin = int

# credential =
#   [  0, addr_keyhash
#   // 1, scripthash
#   ]
# note: implemented in src/address/

# drep =
#   [ 0, addr_keyhash
#   // 1, scripthash
#   // 2  ; always abstain
#   // 3  ; always no confidence
#   ]
DRep:
  type: tagged_record
  variants:
    - name: key_hash
      tag: 0
      value: Ed25519KeyHash
    - name: script_hash
      tag: 1
      value: ScriptHash
    - name: always_abstain
      tag: 2
      kind_name: AlwaysAbstain
    - name: always_no_confidence
      tag: 3
      kind_name: AlwaysNoConfidence

# stake_credential = credential
# drep_credential = credential
# committee_cold_credential = credential
# committee_hot_credential = credential

# pool_params = ( operator:       pool_keyhash
#               , vrf_keyhash:    vrf_keyhash
#               , pledge:         coin
#               , cost:           coin
#               , margin:         unit_interval
#               , reward_account: reward_account
#               , pool_owners:    set<addr_keyhash>
#               , relays:         [* relay]
#               , pool_metadata:  pool_metadata / null
#               )
PoolParams:
  type: record_fragment
  fields:
    - name: operator
      type: Ed25519KeyHash
    - name: vrf_keyhash
      type: VRFKeyHash
    - name: pledge
      type: BigNum
    - name: cost
      type: BigNum
    - name: margin
      type: UnitInterval
    - name: reward_account
      type: RewardAddress
    - name: pool_owners
      type: Ed25519KeyHashes
    - name: relays
      type: Relays
    - name: pool_metadata
      type: PoolMetadata
      nullable: true

Relays:
  type: array
  item: Relay

# port = uint .le 65535
# ipv4 = bytes .size 4
# ipv6 = bytes .size 16
# dns_name = tstr .size (0..128)

Ipv4:
  type: newtype
  item: bytes
  accessor: ip
  constraints:
    len:
      eq: 4

Ipv6:
  type: newtype
  item: bytes
  accessor: ip
  constraints:
    len:
      eq: 16

DNSRecordAorAAAA:
  type: newtype
  item: string
  accessor: record
  constraints:
    len:
      max: 64

DNSRecordSRV:
  type: newtype
  item: string
  accessor: record
  constraints:
    len:
      max: 64

# single_host_addr = ( 0
#                    , port / null
#                    , ipv4 / null
#                    , ipv6 / null
#                    )
# single_host_name = ( 1
#                    , port / null
#                    , dns_name ; An A or AAAA DNS record
#                    )
# multi_host_name = ( 2
#                    , dns_name ; A SRV DNS record
#                    )
# relay =
#   [  single_host_addr
#   // single_host_name
#   // multi_host_name
#   ]
Relay:
  type: tagged_record
  variants:
    - name: single_host_addr
      tag: 0
      value: SingleHostAddr
    - name: single_host_name
      tag: 1
      value: SingleHostName
    - name: multi_host_name
      tag: 2
      value: MultiHostName

SingleHostAddr:
  type: record_fragment
  fields:
    - name: port
      type: number
      nullable: true
    - name: ipv4
      type: Ipv4
      nullable: true
    - name: ipv6
      type: Ipv6
      nullable: true

SingleHostName:
  type: record_fragment
  fields:
    - name: port
      type: number
      nullable: true
    - name: dns_name
      type: DNSRecordAorAAAA

MultiHostName:
  type: record_fragment
  fields:
    - name: dns_name
      type: DNSRecordSRV

# pool_metadata = [url, pool_metadata_hash]
PoolMetadata:
  type: record
  fields:
    - name: url
      type: URL
    - name: pool_metadata_hash
      type: PoolMetadataHash

# url = tstr .size (0..128)
URL:
  type: newtype
  item: string
  accessor: url
  constraints:
    len:
      min: 0
      max: 128

# withdrawals = { + reward_account => coin }
Withdrawals:
  type: map
  key: RewardAddress
  value: BigNum

# protocol_param_update =
#   { ? 0:  coin                   ; minfee A
#   , ? 1:  coin                   ; minfee B
#   , ? 2:  uint                   ; max block body size
#   , ? 3:  uint                   ; max transaction size
#   , ? 4:  uint                   ; max block header size
#   , ? 5:  coin                   ; key deposit
#   , ? 6:  coin                   ; pool deposit
#   , ? 7:  epoch                  ; maximum epoch
#   , ? 8:  uint                   ; n_opt: desired number of stake pools
#   , ? 9:  nonnegative_interval   ; pool pledge influence
#   , ? 10: unit_interval          ; expansion rate
#   , ? 11: unit_interval          ; treasury growth rate
#   , ? 16: coin                   ; min pool cost
#   , ? 17: coin                   ; ada per utxo byte
#   , ? 18: costmdls               ; cost models for script languages
#   , ? 19: ex_unit_prices         ; execution costs
#   , ? 20: ex_units               ; max tx ex units
#   , ? 21: ex_units               ; max block ex units
#   , ? 22: uint                   ; max value size
#   , ? 23: uint                   ; collateral percentage
#   , ? 24: uint                   ; max collateral inputs
#   , ? 25: pool_voting_thresholds ; pool voting thresholds
#   , ? 26: drep_voting_thresholds ; DRep voting thresholds
#   , ? 27: uint                   ; min committee size
#   , ? 28: epoch                  ; committee term limit
#   , ? 29: epoch                  ; governance action validity period
#   , ? 30: coin                   ; governance action deposit
#   , ? 31: coin                   ; DRep deposit
#   , ? 32: epoch                  ; DRep inactivity period
#   , ? 33: nonnegative_interval   ; MinFee RefScriptCostPerByte
#   }
# Note: CSL uses unit_interval in place of nonnegative_interval
ProtocolParamUpdate:
  type: struct
  fields:
    - id: 0
      name: minfee_a
      type: BigNum
      optional: true
    - id: 1
      name: minfee_b
      type: BigNum
      optional: true
    - id: 2
      name: max_block_body_size
      type: number
      optional: true
    - id: 3
      name: max_tx_size
      type: number
      optional: true
    - id: 4
      name: max_block_header_size
      type: number
      optional: true
    - id: 5
      name: key_deposit
      type: BigNum
      optional: true
    - id: 6
      name: pool_deposit
      type: BigNum
      optional: true
    - id: 7
      name: max_epoch
      type: number
      optional: true
    - id: 8
      name: n_opt
      type: number
      optional: true
    - id: 9
      name: pool_pledge_influence
      type: UnitInterval
      optional: true
    - id: 10
      name: expansion_rate
      type: UnitInterval
      optional: true
    - id: 11
      name: treasury_growth_rate
      type: UnitInterval
      optional: true
    - id: 16
      name: min_pool_cost
      type: BigNum
      optional: true
    - id: 17
      name: ada_per_utxo_byte
      type: BigNum
      optional: true
    - id: 18
      name: cost_models
      type: Costmdls
      optional: true
    - id: 19
      name: execution_costs
      type: ExUnitPrices
      optional: true
    - id: 20
      name: max_tx_ex_units
      type: ExUnits
      optional: true
    - id: 21
      name: max_block_ex_units
      type: ExUnits
      optional: true
    - id: 22
      name: max_value_size
      type: number
      optional: true
    - id: 23
      name: collateral_percentage
      type: number
      optional: true
    - id: 24
      name: max_collateral_inputs
      type: number
      optional: true
    - id: 25
      name: pool_voting_thresholds
      type: PoolVotingThresholds
      optional: true
    - id: 26
      name: drep_voting_thresholds
      type: DRepVotingThresholds
      optional: true
    - id: 27
      name: min_committee_size
      type: number
      optional: true
    - id: 28
      name: committee_term_limit
      type: number
      optional: true
    - id: 29
      name: governance_action_validity_period
      type: number
      optional: true
    - id: 30
      name: governance_action_deposit
      type: BigNum
      optional: true
    - id: 31
      name: drep_deposit
      type: BigNum
      optional: true
    - id: 32
      name: drep_inactivity_period
      type: number
      optional: true
    - id: 33
      name: ref_script_coins_per_byte
      type: UnitInterval
      optional: true
  methods:
    new: null
  extra_methods: |
    static new(): ProtocolParamUpdate {
      return new ProtocolParamUpdate(
        undefined,
        undefined,
        undefined,
        undefined,
        undefined,
        undefined,
        undefined,
        undefined,
        undefined,
        undefined,
        undefined,
        undefined,
        undefined,
        undefined,
        undefined,
        undefined,
        undefined,
        undefined,
        undefined,
        undefined,
        undefined,
        undefined,
        undefined,
        undefined,
        undefined,
        undefined,
        undefined,
        undefined,
        undefined,
        undefined,
      );
    }

# pool_voting_thresholds =
#   [ unit_interval ; motion no confidence
#   , unit_interval ; committee normal
#   , unit_interval ; committee no confidence
#   , unit_interval ; hard fork initiation
#   , unit_interval ; security relevant parameter voting threshold
#   ]
PoolVotingThresholds:
  type: record
  fields:
    - name: motion_no_confidence
      type: UnitInterval
    - name: committee_normal
      type: UnitInterval
    - name: committee_no_confidence
      type: UnitInterval
    - name: hard_fork_initiation
      type: UnitInterval
    - name: security_relevant_threshold
      type: UnitInterval

# drep_voting_thresholds =
#   [ unit_interval ; motion no confidence
#   , unit_interval ; committee normal
#   , unit_interval ; committee no confidence
#   , unit_interval ; update constitution
#   , unit_interval ; hard fork initiation
#   , unit_interval ; PP network group
#   , unit_interval ; PP economic group
#   , unit_interval ; PP technical group
#   , unit_interval ; PP governance group
#   , unit_interval ; treasury withdrawal
#   ]
DRepVotingThresholds:
  type: record
  fields:
    - name: motion_no_confidence
      type: UnitInterval
    - name: committee_normal
      type: UnitInterval
    - name: committee_no_confidence
      type: UnitInterval
    - name: update_constitution
      type: UnitInterval
    - name: hard_fork_initiation
      type: UnitInterval
    - name: pp_network_group
      type: UnitInterval
    - name: pp_economic_group
      type: UnitInterval
    - name: pp_technical_group
      type: UnitInterval
    - name: pp_governance_group
      type: UnitInterval
    - name: treasury_withdrawal
      type: UnitInterval

# transaction_witness_set =
#   { ? 0: nonempty_set<vkeywitness>
#   , ? 1: nonempty_set<native_script>
#   , ? 2: nonempty_set<bootstrap_witness>
#   , ? 3: nonempty_set<plutus_v1_script>
#   , ? 4: nonempty_set<plutus_data>
#   , ? 5: redeemers
#   , ? 6: nonempty_set<plutus_v2_script>
#   , ? 7: nonempty_set<plutus_v3_script>
#   }
TransactionWitnessSet:
  type: struct
  fields:
    - id: 0
      name: vkeys
      type: Vkeywitnesses
      optional: true
    - id: 1
      name: native_scripts
      type: NativeScripts
      optional: true
    - id: 2
      name: bootstraps
      type: BootstrapWitnesses
      optional: true
    - id: 3
      name: plutus_scripts_v1
      type: PlutusScripts
      optional: true
    - id: 4
      name: inner_plutus_data
      type: PlutusSet
      optional: true
    - id: 6
      name: plutus_scripts_v2
      type: PlutusScripts
      optional: true
    - id: 5
      name: redeemers
      type: Redeemers
      optional: true
    - id: 7
      name: plutus_scripts_v3
      type: PlutusScripts
      optional: true
  methods:
    new: null
  extra_methods: |
    static new(): TransactionWitnessSet {
      return new TransactionWitnessSet(
        undefined,
        undefined,
        undefined,
        undefined,
        undefined,
        undefined,
        undefined,
        undefined,
      );
    }

    plutus_data(): PlutusList | undefined {
      return this.inner_plutus_data()?.as_list();
    }

    set_plutus_data(plutus_data: PlutusList): void {
      this._inner_plutus_data = plutus_data.as_set();
    }

Vkeywitnesses:
  type: set
  item: Vkeywitness

NativeScripts:
  type: set
  item: NativeScript

BootstrapWitnesses:
  type: set
  item: BootstrapWitness

PlutusScripts:
  type: set
  item: PlutusScript

PlutusScript:
  type: newtype
  item: bytes
  accessor: bytes
  extra_methods: |
    hash(language_version: number): ScriptHash {
      let bytes = new Uint8Array(this.bytes().length + 1);
      bytes[0] = language_version;
      bytes.set(this.bytes(), 1);
      let hash_bytes = cdlCrypto.blake2b224(bytes);
      return new ScriptHash(hash_bytes);
    }

PlutusSet:
  type: set
  item: PlutusData
  extra_methods: |
    as_list(): PlutusList {
      return new PlutusList(this.items, this.definiteEncoding);
    }

# ; The real type of  plutus_v1_script, plutus_v2_script and plutus_v3_script is bytes.
# ; However, because we enforce uniqueness when many scripts are supplied,
# ; we need to hack around for tests in order to avoid generating duplicates,
# ; since the cddl tool we use for roundtrip testing doesn't generate distinct collections.
# plutus_v1_script = distinct<bytes>
# plutus_v2_script = distinct<bytes>
# plutus_v3_script = distinct<bytes>

# plutus_data =
#     constr<plutus_data>
#   / { * plutus_data => plutus_data }
#   / [ * plutus_data ]
#   / big_int
#   / bounded_bytes
# TODO: Custom

# big_int = int / big_uint / big_nint
# big_uint = #6.2(bounded_bytes)
# big_nint = #6.3(bounded_bytes)

# constr<a> =
#     #6.121([* a])
#   / #6.122([* a])
#   / #6.123([* a])
#   / #6.124([* a])
#   / #6.125([* a])
#   / #6.126([* a])
#   / #6.127([* a])
#   ; similarly for tag range: 6.128 .. 6.140 inclusive
#   / #6.102([uint, [* a]])
#   TODO: Custom

# ; Flat Array support is included for backwards compatibility and will be removed in the next era.
# ; It is recommended for tools to adopt using a Map instead of Array going forward.
# redeemers =
#   [ + [ tag: redeemer_tag, index: uint, data: plutus_data, ex_units: ex_units ] ]
#   / { + [ tag: redeemer_tag, index: uint ] => [ data: plutus_data, ex_units: ex_units ] }
#   TODO: Custom

# redeemer_tag =
#     0 ; Spending
#   / 1 ; Minting
#   / 2 ; Certifying
#   / 3 ; Rewarding
#   / 4 ; Voting
#   / 5 ; Proposing
RedeemerTag:
  type: enum
  values:
    - name: spending
      value: 0
    - name: minting
      value: 1
    - name: certifying
      value: 2
    - name: rewarding
      value: 3
    - name: voting
      value: 4
    - name: proposing
      value: 5

# ex_units = [mem: uint, steps: uint]
ExUnits:
  type: record
  fields:
    - name: mem
      type: BigNum
    - name: steps
      type: BigNum

# ex_unit_prices =
#   [ mem_price: nonnegative_interval, step_price: nonnegative_interval ]
# Note: CSL uses unit_interval in place of nonnegative_interval
ExUnitPrices:
  type: record
  fields:
    - name: mem_price
      type: UnitInterval
    - name: step_price
      type: UnitInterval

# language = 0 ; Plutus v1
#          / 1 ; Plutus v2
#          / 2 ; Plutus v3
Language:
  type: enum
  values:
    - name: plutus_v1
      value: 0
    - name: plutus_v2
      value: 1
    - name: plutus_v3
      value: 2

# potential_languages = 0 .. 255
# potential_languages:
#   type: uint
#   value:
#     min: 0
#     max: 255

# ; The format for costmdls is flexible enough to allow adding Plutus built-ins and language
# ; versions in the future.
# ;
# costmdls =
#   { ? 0 : [ 166* int ] ; Plutus v1, only 166 integers are used, but more are accepted (and ignored)
#   , ? 1 : [ 175* int ] ; Plutus v2, only 175 integers are used, but more are accepted (and ignored)
#   , ? 2 : [ 233* int ] ; Plutus v3, only 233 integers are used, but more are accepted (and ignored)
#   , ? 3 : [ int ] ; Any 8-bit unsigned number can be used as a key.
#   }
#   TODO: Rewrite as custom
#         CostMdls is Map<Language, CostModel>
#         CostModel is custom Vec<Int>:
#           get(operation): self[operation]
#           set(operation, cost): fill zero from self.len to operation; self[operation] = cost
# TODO: Custom

# transaction_metadatum =
#     { * transaction_metadatum => transaction_metadatum }
#   / [ * transaction_metadatum ]
#   / int
#   / bytes .size (0..64)
#   / text .size (0..64)
#   TODO: Custom

# transaction_metadatum_label = uint

# metadata = { * transaction_metadatum_label => transaction_metadatum }
GeneralTransactionMetadata:
  type: map
  key: BigNum
  value: TransactionMetadatum
  keys_method_type: TransactionMetadatumLabels

TransactionMetadatumLabels:
  type: array
  item: BigNum

# auxiliary_data =
#   metadata ; Shelley
#   / [ transaction_metadata: metadata ; Shelley-ma
#     , auxiliary_scripts: [ * native_script ]
#     ]
#   / #6.259({ ? 0 => metadata         ; Alonzo and beyond
#       , ? 1 => [ * native_script ]
#       , ? 2 => [ * plutus_v1_script ]
#       , ? 3 => [ * plutus_v2_script ]
#       , ? 4 => [ * plutus_v3_script ]
#       })
AuxiliaryData:
  type: union
  variants:
    - tag: 0
      peek_type: map
      name: shelley_metadata
      type: GeneralTransactionMetadata
    - tag: 1
      peek_type: array
      name: shelley_metadata_ma
      type: AuxiliaryDataShelleyMa
    - tag: 2
      peek_type: tagged
      name: postalonzo_metadata
      type: AuxiliaryDataPostAlonzo
  methods:
    new: null
  extra_methods: |
    static new(): AuxiliaryData {
      const post_alonzo_auxiliary_data = new AuxiliaryDataPostAlonzo(
        GeneralTransactionMetadata.new(),
        NativeScripts.new(),
        PlutusScripts.new(),
        PlutusScripts.new(),
        PlutusScripts.new(),
      );
      return new AuxiliaryData({kind: 2, value: post_alonzo_auxiliary_data})
    }

    metadata(): GeneralTransactionMetadata | undefined {
      switch (this.variant.kind) {
        case 0:
          return this.variant.value;
        case 1:
          return this.variant.value.transaction_metadata();
        case 2:
          return this.variant.value.metadata();
      }
    }

    set_metadata(metadata: GeneralTransactionMetadata): void {
      switch (this.variant.kind) {
        case 0:
          this.variant = { kind: 0, value: metadata };
          break;
        case 1:
          this.variant.value.set_transaction_metadata(metadata);
          break;
        case 2:
          this.variant.value.set_metadata(metadata);
          break;
      }
    }

    native_scripts(): NativeScripts | undefined {
      switch (this.variant.kind) {
        case 0:
          return undefined;
        case 1:
          return this.variant.value.auxiliary_scripts();
        case 2:
          return this.variant.value.native_scripts();
      }
    }

    set_native_scripts(native_scripts: NativeScripts): void {
      switch (this.variant.kind) {
        case 0:
          let v = AuxiliaryDataPostAlonzo.new(
            this.variant.value,
            native_scripts,
            undefined,
            undefined,
            undefined,
          );
          this.variant = { kind: 2, value: v };
          break;
        case 1:
          this.variant.value.set_auxiliary_scripts(native_scripts);
          break;
        case 2:
          this.variant.value.set_native_scripts(native_scripts);
          break;
      }
    }

    plutus_scripts_v1(): PlutusScripts | undefined {
      switch (this.variant.kind) {
        case 0:
          return undefined;
        case 1:
          return undefined;
        case 2:
          return this.variant.value.plutus_scripts_v1();
      }
    }

    set_plutus_scripts_v1(plutus_scripts_v1: PlutusScripts): void {
      switch (this.variant.kind) {
        case 0:
          let v1 = AuxiliaryDataPostAlonzo.new(
            this.variant.value,
            undefined,
            plutus_scripts_v1,
            undefined,
            undefined,
          );
          this.variant = { kind: 2, value: v1 };
          break;
        case 1:
          let v2 = AuxiliaryDataPostAlonzo.new(
            this.variant.value.transaction_metadata(),
            this.variant.value.auxiliary_scripts(),
            plutus_scripts_v1,
            undefined,
            undefined,
          );
          this.variant = { kind: 2, value: v2 };
          break;
        case 2:
          this.variant.value.set_plutus_scripts_v1(plutus_scripts_v1);
          break;
      }
    }

    plutus_scripts_v2(): PlutusScripts | undefined {
      switch (this.variant.kind) {
        case 0:
          return undefined;
        case 1:
          return undefined;
        case 2:
          return this.variant.value.plutus_scripts_v2();
      }
    }

    set_plutus_scripts_v2(plutus_scripts_v2: PlutusScripts): void {
      switch (this.variant.kind) {
        case 0:
          let v1 = AuxiliaryDataPostAlonzo.new(
            this.variant.value,
            undefined,
            undefined,
            plutus_scripts_v2,
            undefined,
          );
          this.variant = { kind: 2, value: v1 };
          break;
        case 1:
          let v2 = AuxiliaryDataPostAlonzo.new(
            this.variant.value.transaction_metadata(),
            this.variant.value.auxiliary_scripts(),
            undefined,
            plutus_scripts_v2,
            undefined,
          );
          this.variant = { kind: 2, value: v2 };
          break;
        case 2:
          this.variant.value.set_plutus_scripts_v2(plutus_scripts_v2);
          break;
      }
    }

    plutus_scripts_v3(): PlutusScripts | undefined {
      switch (this.variant.kind) {
        case 0:
          return undefined;
        case 1:
          return undefined;
        case 2:
          return this.variant.value.plutus_scripts_v3();
      }
    }

    set_plutus_scripts_v3(plutus_scripts_v3: PlutusScripts): void {
      switch (this.variant.kind) {
        case 0:
          let v3 = AuxiliaryDataPostAlonzo.new(
            this.variant.value,
            undefined,
            undefined,
            undefined,
            plutus_scripts_v3,
          );
          this.variant = { kind: 2, value: v3 };
          break;
        case 1:
          let v2 = AuxiliaryDataPostAlonzo.new(
            this.variant.value.transaction_metadata(),
            this.variant.value.auxiliary_scripts(),
            undefined,
            undefined,
            plutus_scripts_v3,
          );
          this.variant = { kind: 2, value: v2 };
          break;
        case 2:
          this.variant.value.set_plutus_scripts_v3(plutus_scripts_v3);
          break;
      }
    }

# vkeywitness = [ $vkey, $signature ]
Vkeywitness:
  type: record
  fields:
    - name: vkey
      type: Vkey
    - name: signature
      type: Ed25519Signature

# bootstrap_witness =
#   [ public_key : $vkey
#   , signature  : $signature
#   , chain_code : bytes .size 32
#   , attributes : bytes
#   ]
BootstrapWitness:
  type: record
  fields:
    - name: vkey
      type: Vkey
    - name: signature
      type: Ed25519Signature
    - name: chain_code
      type: bytes
    - name: attributes
      type: bytes

# native_script =
#   [ script_pubkey
#   // script_all
#   // script_any
#   // script_n_of_k
#   // invalid_before
#      ; Timelock validity intervals are half-open intervals [a, b).
#      ; This field specifies the left (included) endpoint a.
#   // invalid_hereafter
#      ; Timelock validity intervals are half-open intervals [a, b).
#      ; This field specifies the right (excluded) endpoint b.
#   ]
# script_pubkey = (0, addr_keyhash)
# script_all = (1, [ * native_script ])
# script_any = (2, [ * native_script ])
# script_n_of_k = (3, n: uint, [ * native_script ])
# invalid_before = (4, uint)
# invalid_hereafter = (5, uint)
NativeScript:
  type: tagged_record
  variants:
    - name: script_pubkey
      tag: 0
      value: ScriptPubkey
    - name: script_all
      tag: 1
      value: ScriptAll
    - name: script_any
      tag: 2
      value: ScriptAny
    - name: script_n_of_k
      tag: 3
      value: ScriptNOfK
    - name: timelock_start
      tag: 4
      value: TimelockStart
    - name: timelock_expiry
      tag: 5
      value: TimelockExpiry

ScriptPubkey:
  type: newtype
  item: Ed25519KeyHash
  accessor: addr_keyhash

ScriptPubname:
  type: record_fragment
  fields:
    - name: addr_keyhash
      type: Ed25519KeyHash

ScriptAll:
  type: record_fragment
  fields:
    - name: native_scripts
      type: NativeScripts

ScriptAny:
  type: record_fragment
  fields:
    - name: native_scripts
      type: NativeScripts

ScriptNOfK:
  type: record_fragment
  fields:
    - name: n
      type: number
    - name: native_scripts
      type: NativeScripts

TimelockStart:
  type: record_fragment
  fields:
    - name: slot
      type: BigNum
  methods:
    new: new_timelockstart
    slot: slot_bignum
  extra_methods: |
    slot(): number  {
      return this.slot_bignum()._to_number();
    }

    static new(slot: number): TimelockStart {
      return new TimelockStart(BigNum._from_number(slot));
    }

TimelockExpiry:
  type: record_fragment
  fields:
    - name: slot
      type: BigNum
  methods:
    new: new_timelockexpiry
    slot: slot_bignum
  extra_methods: |
    slot(): number  {
      return this.slot_bignum()._to_number();
    }

    static new(slot: number): TimelockExpiry {
      return new TimelockExpiry(BigNum._from_number(slot));
    }

# coin = uint

# multiasset<a> = { + policy_id => { + asset_name => a } }
# TODO: Custom

# policy_id = scripthash

# asset_name = bytes .size (0..32)
AssetName:
  type: newtype
  item: bytes
  accessor: name
  constraints:
    len:
      max: 32

# negInt64 = -9223372036854775808 .. -1

# posInt64 = 1 .. 9223372036854775807

# nonZeroInt64 = negInt64 / posInt64 ; this is the same as the current int64 definition but without zero

# positive_coin = 1 .. 18446744073709551615

# value = coin / [coin, multiasset<positive_coin>]
# TODO: Custom

# mint = multiasset<nonZeroInt64>
# TODO: Custom

# int64 = -9223372036854775808 .. 9223372036854775807

# network_id = 0 / 1
NetworkId:
  type: enum
  values:
    - name: mainnet
      value: 1
    - name: testnet
      value: 0

# epoch = uint

# addr_keyhash           = $hash28
# pool_keyhash           = $hash28
# vrf_keyhash           = $hash32
# auxiliary_data_hash   = $hash32
# pool_metadata_hash    = $hash32

# ; To compute a script hash, note that you must prepend
# ; a tag to the bytes of the script before hashing.
# ; The tag is determined by the language.
# ; The tags in the Conway era are:
# ;   "\x00" for multisig scripts
# ;   "\x01" for Plutus V1 scripts
# ;   "\x02" for Plutus V2 scripts
# ;   "\x03" for Plutus V3 scripts
# scripthash            = $hash28

# datum_hash = $hash32

# data = #6.24(bytes .cbor plutus_data)
Data:
  type: newtype
  item: bytes
  accessor: encoded_plutus_data
  tagged:
    tag: 24

# datum_option = [ 0, $hash32 // 1, data ]
DataOption:
  type: tagged_record
  variants:
    - name: hash
      tag: 0
      value: DataHash
    - name: data
      tag: 1
      value: Data

# script_ref = #6.24(bytes .cbor script)

# script = [ 0, native_script // 1, plutus_v1_script // 2, plutus_v2_script // 3, plutus_v3_script ]
ScriptRef:
  type: tagged_record
  methods:
    deserialize: deserializeInner
    serialize: serializeInner
  extra_methods: |
    static deserialize(reader: CBORReader, path: string[]): ScriptRef {
      const tag = reader.readTaggedTag(path);
      if (tag != 24) {
        throw new Error("Expected a CBOR encoded item when deserializing ScriptRef (at " + path.join('/') + ")");
      }
      let bytes = reader.readBytes(path);
      let new_reader = new CBORReader(bytes);

      return ScriptRef.deserializeInner(new_reader, path)      
    }

    serialize(writer: CBORWriter): void {
      writer.writeTaggedTag(24);

      let bytes_writer = new CBORWriter();
      this.serializeInner(bytes_writer);
      let bytes = bytes_writer.getBytes();

      writer.writeBytes(bytes);
    }
  variants:
    - name: native_script
      tag: 0
      value: NativeScript
    - name: plutus_script_v1
      tag: 1
      value: PlutusScript
      kind_name: PlutusScriptV1
    - name: plutus_script_v2
      tag: 2
      value: PlutusScript
      kind_name: PlutusScriptV2
    - name: plutus_script_v3
      tag: 3
      value: PlutusScript
      kind_name: PlutusScriptV3

UnitInterval:
  type: record
  fields:
    - name: numerator
      type: BigNum
    - name: denominator
      type: BigNum
  tagged:
    tag: 30

Update:
  type: record
  fields:
    - name: proposed_protocol_parameter_updates
      type: ProposedProtocolParameterUpdates
    - name: epoch
      type: number

ProposedProtocolParameterUpdates:
  type: map
  key: GenesisHash
  value: ProtocolParamUpdate
  keys_method_type: GenesisHashes

PlutusList:
  type: array
  item: PlutusData
  extra_methods: |
    as_set(): PlutusSet {
      let set = new PlutusSet(this.definiteEncoding);
      for (let i = 0; i < this.len(); i++) {
        set.add(this.items[i]);
      }
      return set;
    }

PlutusMap:
  type: map
  key: PlutusData
  value: PlutusData
  keys_method_type: PlutusList
  methods:
    get: getInner
    insert: insertInner
  extra_methods: |
    get(key: PlutusData): PlutusMapValues | undefined {
      let v: PlutusData | undefined = this.getInner(key);
      if(v) {
        let vs = new PlutusMapValues([v]);
        return vs;
      } else {
        return undefined;
      }
    }

    insert(key: PlutusData, values: PlutusMapValues): PlutusMapValues | undefined {
      let v: PlutusData = values.get(values.len() - 1);
      let ret: PlutusData | undefined = this.insertInner(key, v);
      if (ret) {
        return new PlutusMapValues([ret]);
      } else {
        return undefined;
      }
    }

PlutusMapValues:
  type: array
  item: PlutusData

TreasuryWithdrawals:
  type: map
  key: RewardAddress
  value: BigNum
  keys_method_type: RewardAddresses

RewardAddresses:
  type: array
  item: RewardAddress

VRFCert:
  type: record
  fields:
    - name: output
      type: bytes
    - name: proof
      type: bytes

DataCost:
  type: record
  fields:
    - name: coins_per_byte
      type: BigNum

OutputDatum:
  type: tagged_record
  variants:
    - name: data_hash
      tag: 0
      value: DataHash
    - name: data
      tag: 1
      value: PlutusData

Vkey:
  type: record
  fields:
    - name: public_key
      type: PublicKey
  methods:
    deserialize: null
    serialize: null
  extra_methods: |
    static deserialize(reader: CBORReader, path: string[]): Vkey {
      const public_key_path = [...path, "PublicKey(public_key)"];
      let public_key = PublicKey.deserialize(reader, public_key_path);
      return new Vkey(public_key);
    }

    serialize(writer: CBORWriter): void {
      this._public_key.serialize(writer);
    }

Vkeys:
  type: array
  item: Vkey
